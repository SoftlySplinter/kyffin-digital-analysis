<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>IVT: ImageProcessor Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">IVT</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('namespace_image_processor.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ImageProcessor Namespace Reference<div class="ingroups"><a class="el" href="group___image_processing.html">Image processing</a></div></div>  </div>
</div>
<div class="contents">

<p>Central namespace offering various image processing routines and functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a97586c1de02d705c7415a74bde1430ab">BayerPatternType</a> { <a class="el" href="namespace_image_processor.html#a97586c1de02d705c7415a74bde1430aba99299a695eae11d3915262235e6a8f44">eBayerRG</a>, 
<a class="el" href="namespace_image_processor.html#a97586c1de02d705c7415a74bde1430aba2189d8007f93129b1a6971652ec69b6e">eBayerGR</a>, 
<a class="el" href="namespace_image_processor.html#a97586c1de02d705c7415a74bde1430abaaca69c5c21d22afe8d1d639fd53f7e13">eBayerBG</a>, 
<a class="el" href="namespace_image_processor.html#a97586c1de02d705c7415a74bde1430aba6fb1c443f1ebb086ca12c1d5a2dd3101">eBayerGB</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The four possible variants for Bayer pattern conversion.  <a href="namespace_image_processor.html#a97586c1de02d705c7415a74bde1430ab">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#aca48232f18c62f07c33d972fba58f5fb">ConvertImage</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, bool bFast=false, const <a class="el" href="struct_my_region.html">MyRegion</a> *pROI=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to an RGB <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> image and vice versa.  <a href="#aca48232f18c62f07c33d972fba58f5fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a0f5e64ac6135385f6a6a551e6d603e5b">ConvertImage</a> (const <a class="el" href="class_c_float_image.html">CFloatImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, bool equalize=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="class_c_float_image.html" title="Data structure for the representation of any image type (arbitrary number of channels) using the data...">CFloatImage</a> to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a0f5e64ac6135385f6a6a551e6d603e5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a148f646ee2651dc3ab33bcc4de0c1042">ConvertImage</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_float_image.html">CFloatImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to a <a class="el" href="class_c_float_image.html" title="Data structure for the representation of any image type (arbitrary number of channels) using the data...">CFloatImage</a>.  <a href="#a148f646ee2651dc3ab33bcc4de0c1042"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a8716bb2c22c678699c4cb3703cc9f2a5">ConvertImage</a> (const <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a> to a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a8716bb2c22c678699c4cb3703cc9f2a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#ace8d9db64bf4b5ebd04711f4efb1cecd">ConvertImage</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a>.  <a href="#ace8d9db64bf4b5ebd04711f4efb1cecd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a53d89906c569cf675efbb413012efce0">ConvertImage</a> (const <a class="el" href="class_c_short_image.html">CShortImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a> to a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a53d89906c569cf675efbb413012efce0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a841ce8bfce0143c3aed02733f31aacf0">ConvertImage</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_short_image.html">CShortImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>.  <a href="#a841ce8bfce0143c3aed02733f31aacf0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a2c4640c7060531d9e7bcac387b5349b1">ConvertImage</a> (const <a class="el" href="class_c_int_image.html">CIntImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="class_c_int_image.html" title="Data structure for the representation of single channel images of the data type signed int...">CIntImage</a> to a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a2c4640c7060531d9e7bcac387b5349b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#aee2bfde18b4d47cc961411236f962bf7">ConvertImage</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_int_image.html">CIntImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to a <a class="el" href="class_c_int_image.html" title="Data structure for the representation of single channel images of the data type signed int...">CIntImage</a>.  <a href="#aee2bfde18b4d47cc961411236f962bf7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a07707c758ade7627050600d3f56b75a2">ConvertMatrix</a> (const <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *pInputImage, <a class="el" href="class_c_double_matrix.html">CDoubleMatrix</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a> to a <a class="el" href="class_c_double_matrix.html" title="Data structure for the representation of a matrix of values of the data type double.">CDoubleMatrix</a>.  <a href="#a07707c758ade7627050600d3f56b75a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#ad89ae984474f2647205adea1f32b78d9">ConvertMatrix</a> (const <a class="el" href="class_c_double_matrix.html">CDoubleMatrix</a> *pInputImage, <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="class_c_double_matrix.html" title="Data structure for the representation of a matrix of values of the data type double.">CDoubleMatrix</a> to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a>.  <a href="#ad89ae984474f2647205adea1f32b78d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a243bcd983a82e63ca4aa97ca2a72af58">CopyImage</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, const <a class="el" href="struct_my_region.html">MyRegion</a> *pROI=0, bool bUseSameSize=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies one <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to another.  <a href="#a243bcd983a82e63ca4aa97ca2a72af58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a72f046becee4a6661d2651d7b6812785">CopyImage</a> (const <a class="el" href="class_c_short_image.html">CShortImage</a> *pInputImage, <a class="el" href="class_c_short_image.html">CShortImage</a> *pOutputImage, const <a class="el" href="struct_my_region.html">MyRegion</a> *pROI=0, bool bUseSameSize=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies one <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a> to another.  <a href="#a72f046becee4a6661d2651d7b6812785"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#ae68350981446bf610a01cfc23e4b77f6">CopyMatrix</a> (const <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *pInputImage, <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies one <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a> to another.  <a href="#ae68350981446bf610a01cfc23e4b77f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#af340a142efb40efc254570bf2dd7793d">CopyMatrix</a> (const <a class="el" href="class_c_double_matrix.html">CDoubleMatrix</a> *pInputImage, <a class="el" href="class_c_double_matrix.html">CDoubleMatrix</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies one <a class="el" href="class_c_double_matrix.html" title="Data structure for the representation of a matrix of values of the data type double.">CDoubleMatrix</a> to another.  <a href="#af340a142efb40efc254570bf2dd7793d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#ade446a86e131c0315ea33c228c39d692">Zero</a> (<a class="el" href="class_c_byte_image.html">CByteImage</a> *pImage, const <a class="el" href="struct_my_region.html">MyRegion</a> *pROI=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to zero.  <a href="#ade446a86e131c0315ea33c228c39d692"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#ae0ff463562fada0b7f1f3bee665ecf1a">Zero</a> (<a class="el" href="class_c_short_image.html">CShortImage</a> *pImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values in a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a> to zero.  <a href="#ae0ff463562fada0b7f1f3bee665ecf1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a48ac73db390aa35de5e950436bf48f1b">Zero</a> (<a class="el" href="class_c_int_image.html">CIntImage</a> *pImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values in a <a class="el" href="class_c_int_image.html" title="Data structure for the representation of single channel images of the data type signed int...">CIntImage</a> to zero.  <a href="#a48ac73db390aa35de5e950436bf48f1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a237b98cc8adadf06a90fd13ec878e15f">Zero</a> (<a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *pImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values in a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a> to zero.  <a href="#a237b98cc8adadf06a90fd13ec878e15f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#ad95490e1437fc504620fff392fd2ceca">Zero</a> (<a class="el" href="class_c_double_matrix.html">CDoubleMatrix</a> *pImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values in a <a class="el" href="class_c_double_matrix.html" title="Data structure for the representation of a matrix of values of the data type double.">CDoubleMatrix</a> to zero.  <a href="#ad95490e1437fc504620fff392fd2ceca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a9acfcdc1b4d7e15c29d35e4e8264f196">FlipY</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips the rows in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> vertically and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a9acfcdc1b4d7e15c29d35e4e8264f196"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#ad202012edef5f5c0d5e629c1eb4a4c46">AverageFilter</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, int nMaskSize=3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an average filter to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#ad202012edef5f5c0d5e629c1eb4a4c46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#af5729feba6dfd076a3ceafe8a1dbb7b5">GaussianSmooth</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *pOutputImage, float fVariance, int nKernelSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a Gaussian filter to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a>.  <a href="#af5729feba6dfd076a3ceafe8a1dbb7b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#aad5512260c8fb87ba4f5da68ed9d6214">GaussianSmooth</a> (const <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *pInputImage, <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *pOutputImage, float fVariance, int nKernelSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a Gaussian filter to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a> and writes the result to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a>.  <a href="#aad5512260c8fb87ba4f5da68ed9d6214"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a6813a8de3a33d1da6ae8858b41d43ea8">GaussianSmooth</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, float fVariance, int nKernelSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a Gaussian filter to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a6813a8de3a33d1da6ae8858b41d43ea8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a7beeb95db014939596671aee82c4446a">GaussianSmooth5x5</a> (const <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *pInputImage, <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *pOutputImage, float fVariance)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a 5x5 Gaussian filter to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a> and writes the result to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a>.  <a href="#a7beeb95db014939596671aee82c4446a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#af749560ff627f4e4d610af30b2271212">GaussianSmooth3x3</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a 3x3 Gaussian filter to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#af749560ff627f4e4d610af30b2271212"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#ae58234b3f065a061844c8f7139f57be3">GaussianSmooth5x5</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a 5x5 Gaussian filter to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#ae58234b3f065a061844c8f7139f57be3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a80aba5fb12df62fb1e2c57771a5a5d96">HighPassX3</a> (const <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *pInputImage, <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a 1x3 highpass filter to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a> and write the result to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a>.  <a href="#a80aba5fb12df62fb1e2c57771a5a5d96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a47f052faf74d56cc5e50816e81837b8b">HighPassY3</a> (const <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *pInputImage, <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a 3x1 highpass filter to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a> and writes the result to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a>.  <a href="#a47f052faf74d56cc5e50816e81837b8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a832974296e6d1c7f844f3cdfa59af7a2">SobelX</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_short_image.html">CShortImage</a> *pOutputImage, bool bAbsoluteValue=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with the SobelX operator and writes the result to a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>.  <a href="#a832974296e6d1c7f844f3cdfa59af7a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a15023fba6db7c6159c8674202ee11bc8">SobelX</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, bool bAbsoluteValue=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with the SobelX operator and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a15023fba6db7c6159c8674202ee11bc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a65f699114febf20cf105d7eda847c8da">SobelY</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_short_image.html">CShortImage</a> *pOutputImage, bool bAbsoluteValue=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with the SobelY operator and writes the result to a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>.  <a href="#a65f699114febf20cf105d7eda847c8da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#aed24f95ce40024df3f169cb09ff80af0">SobelY</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, bool bAbsoluteValue=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with the SobelY operator and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#aed24f95ce40024df3f169cb09ff80af0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#aecc27bc30495075798d8861e6fd7cf8c">PrewittX</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_short_image.html">CShortImage</a> *pOutputImage, bool bAbsoluteValue=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with the PrewittX operator and writes the result to a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>.  <a href="#aecc27bc30495075798d8861e6fd7cf8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#ae846f23e4ee223c1fb06e52f674763d5">PrewittX</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, bool bAbsoluteValue=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with the PrewittX operator and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#ae846f23e4ee223c1fb06e52f674763d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a9c099e921d75cf4cf0a2e0677c8c7e52">PrewittY</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_short_image.html">CShortImage</a> *pOutputImage, bool bAbsoluteValue=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with the PrewittY operator and writes the result to a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>.  <a href="#a9c099e921d75cf4cf0a2e0677c8c7e52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#af9f5c50fdfd261f873e4f4ff0c0e03a0">PrewittY</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, bool bAbsoluteValue=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with the PrewittY operator and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#af9f5c50fdfd261f873e4f4ff0c0e03a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#adb680fabbf995350755cdca3da9df3f8">Laplace1</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_short_image.html">CShortImage</a> *pOutputImage, bool bAbsoluteValue=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with the Laplace1 operator and writes the result to a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>.  <a href="#adb680fabbf995350755cdca3da9df3f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a24f814d2ce7acfc8ef63e73c83708c1f">Laplace1</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, bool bAbsoluteValue=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with the Laplace1 operator and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a24f814d2ce7acfc8ef63e73c83708c1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a28fcdca817d678cfd272b36b769e2b90">Laplace2</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_short_image.html">CShortImage</a> *pOutputImage, bool bAbsoluteValue=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with the Laplace2 operator and writes the result to a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>.  <a href="#a28fcdca817d678cfd272b36b769e2b90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a2f55c87dc6c94a8626937c900d200150">Laplace2</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, bool bAbsoluteValue=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with the Laplace2 operator and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a2f55c87dc6c94a8626937c900d200150"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#accfd2be6c64de76484453a654907394b">GeneralFilter</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, const int *pKernel, int nMaskSize, int nDivider=1, bool bAbsoluteValue=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a user defined filter to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#accfd2be6c64de76484453a654907394b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a556ce4364d37a80b44a11017c2bb00dd">GeneralFilter</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_short_image.html">CShortImage</a> *pOutputImage, const int *pKernel, int nMaskSize, int nDivider=1, bool bAbsoluteValue=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a user defined filter to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>.  <a href="#a556ce4364d37a80b44a11017c2bb00dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a8aea7219ff20434c3638734dc35f4f99">GeneralFilter</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *pOutputImage, const int *pKernel, int nMaskSize, int nDivider=1, bool bAbsoluteValue=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a user defined filter to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a>.  <a href="#a8aea7219ff20434c3638734dc35f4f99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a42292832d673ef5acca4b6634fe975a4">CalculateGradientImagePrewitt</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a combined Prewitt filter for both x- and y-direction to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and stores the result in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a42292832d673ef5acca4b6634fe975a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#aaebaca4811777943c3d377ed1aab7354">CalculateGradientImageSobel</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a combined Sobel filter for both x- and y-direction to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and stores the result in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#aaebaca4811777943c3d377ed1aab7354"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a0804f830310cb96b9dd891c7e8122c6c">CalculateGradientImage</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a combined simple gradient filter for both x- and y-direction to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and stores the result in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a0804f830310cb96b9dd891c7e8122c6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a95092a5341161a3cd05343664d963b71">CalculateGradientImageBinary</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a gradient image for a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>, for the special case of binary images.  <a href="#a95092a5341161a3cd05343664d963b71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a315140215774bd6909652ecccaefd695">ApplyAffinePointOperation</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, float a, float b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an affine point operation to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a315140215774bd6909652ecccaefd695"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a77ac686c036567c1fa01682eff53b306">NormalizeColor</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies histogram equalization to all channels of a color <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a77ac686c036567c1fa01682eff53b306"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a670bf3a1bac61bf821f259172c0e9322">HistogramEqualization</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs histogram equalization for a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a670bf3a1bac61bf821f259172c0e9322"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a51855d6ca4445b64cbe4bcb8cb2383cf">HistogramStretching</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, float p1=0.1f, float p2=0.9f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs histogram stretching on pInputImage and stores the result in pOutputImage.  <a href="#a51855d6ca4445b64cbe4bcb8cb2383cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a5775834e0c273da26cb7abd864d15e83">Spread</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a spread operation on pInputImage and stores the result in pOutputImage.  <a href="#a5775834e0c273da26cb7abd864d15e83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a17732d135fd1401ef60bdc84e0c72a5c">ApplyHomography</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, const <a class="el" href="struct_mat3d.html">Mat3d</a> &amp;A, bool bInterpolation=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a homography to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a17732d135fd1401ef60bdc84e0c72a5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#ae18a5f27d3bff537a082ec751a4d6585">ApplyHomography</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, bool bInterpolation=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated.  <a href="#ae18a5f27d3bff537a082ec751a4d6585"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a7f5c80c5cbdd1845c3e9fb6f2a8a24bb">Resize</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, const <a class="el" href="struct_my_region.html">MyRegion</a> *pROI=0, bool bInterpolation=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a7f5c80c5cbdd1845c3e9fb6f2a8a24bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#af18610f17a3f57e840639fb2bc1e1ff1">Rotate</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, float mx, float my, float theta, bool bInterpolation=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates pInputImage to the dimensions specified by pOutputImage and stores the result in pOutputImage.  <a href="#af18610f17a3f57e840639fb2bc1e1ff1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#aca0a8170ac143fbdcfd3515f2b94f353">DetermineHomography</a> (const <a class="el" href="struct_vec2d.html">Vec2d</a> *pSourcePoints, const <a class="el" href="struct_vec2d.html">Vec2d</a> *pTargetPoints, int nPoints, float &amp;a1, float &amp;a2, float &amp;a3, float &amp;a4, float &amp;a5, float &amp;a6, float &amp;a7, float &amp;a8)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated.  <a href="#aca0a8170ac143fbdcfd3515f2b94f353"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#ab54781247aa0baee84e400c52d05f454">DetermineAffineTransformation</a> (const <a class="el" href="struct_vec2d.html">Vec2d</a> *pSourcePoints, const <a class="el" href="struct_vec2d.html">Vec2d</a> *pTargetPoints, int nPoints, float &amp;a1, float &amp;a2, float &amp;a3, float &amp;a4, float &amp;a5, float &amp;a6)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated.  <a href="#ab54781247aa0baee84e400c52d05f454"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#ac54eadd19d9520aba535313eb184b76c">CalculateSaturationImage</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the saturation image for an RGB <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#ac54eadd19d9520aba535313eb184b76c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___color_processing.html#gad49d09ddc58f9ac7eec9ade3db0b8060">FilterRGB</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, <a class="el" href="class_c_r_g_b_color_model.html">CRGBColorModel</a> *pColorModel, float fThreshold)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs color filtering with binarization for an RGB <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>, given a <a class="el" href="class_c_r_g_b_color_model.html" title="Training and application of an RGB color model on the basis of the Mahalanobis distance.">CRGBColorModel</a>, and writes the result to a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="group___color_processing.html#gad49d09ddc58f9ac7eec9ade3db0b8060"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___color_processing.html#ga53e2f2e711a122b234b66b6272111c08">CalculateHSVImage</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, const <a class="el" href="struct_my_region.html">MyRegion</a> *pROI=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the HSV image for a RGB <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="group___color_processing.html#ga53e2f2e711a122b234b66b6272111c08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___color_processing.html#ga89302fec9e78631a1a39a103800a5cd4">FilterHSV</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, unsigned char hue, unsigned char tol_hue, unsigned char min_sat, unsigned char max_sat, unsigned char min_v, unsigned char max_v, const <a class="el" href="struct_my_region.html">MyRegion</a> *pROI=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs color filtering with binarization for an HSV <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="group___color_processing.html#ga89302fec9e78631a1a39a103800a5cd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___color_processing.html#ga5ea6e75e7cfc359429d458572012a13f">FilterHSV2</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, unsigned char min_hue, unsigned char max_hue, unsigned char min_sat, unsigned char max_sat, unsigned char min_v, unsigned char max_v, const <a class="el" href="struct_my_region.html">MyRegion</a> *pROI=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs color filtering with binarization for an HSV <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="group___color_processing.html#ga5ea6e75e7cfc359429d458572012a13f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#aefe8dd246421ba8c838be0accb7f5e95">ZeroFrame</a> (<a class="el" href="class_c_byte_image.html">CByteImage</a> *pImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all pixels on a one pixel wide frame of a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to zero.  <a href="#aefe8dd246421ba8c838be0accb7f5e95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a2e0ef07a0e16170d5fc08c6e025b68a3">ZeroFrame</a> (<a class="el" href="class_c_short_image.html">CShortImage</a> *pImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all pixels on a one pixel wide frame of a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a> to zero.  <a href="#a2e0ef07a0e16170d5fc08c6e025b68a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#ad5c35606a667dbea8cb6ce5568f6f0df">ZeroFrame</a> (<a class="el" href="class_c_int_image.html">CIntImage</a> *pImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all pixels on a one pixel wide frame of a <a class="el" href="class_c_int_image.html" title="Data structure for the representation of single channel images of the data type signed int...">CIntImage</a> to zero.  <a href="#ad5c35606a667dbea8cb6ce5568f6f0df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#aa5ca4cff5ad86826be9735e8b1f0c07b">CopyFrame</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all pixels on a one pixel wide frame from one <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#aa5ca4cff5ad86826be9735e8b1f0c07b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a6d5f9f07ffef7612f0d80f501cedefb4">AdaptFrame</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all pixels on a one pixel wide outer frame in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to the pixel values of the inner frame of a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a6d5f9f07ffef7612f0d80f501cedefb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a6c196fc78d0f79ef77d58fdaf3da54c7">Invert</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverted image of a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a6c196fc78d0f79ef77d58fdaf3da54c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#aa58760b9cf3ec2765fb6221ff44aa038">Amplify</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, float fFactor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies each byte value of a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with a floating point factor and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#aa58760b9cf3ec2765fb6221ff44aa038"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a0a46da9e8e96d255b1e8be830a995c84">Rotate180Degrees</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> by 180 degrees and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a0a46da9e8e96d255b1e8be830a995c84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a2ae90a1ded17ef4234ea928aa0992e95">Canny</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, int nLowThreshold, int nHighThreshold)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the Canny edge detector to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a2ae90a1ded17ef4234ea928aa0992e95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#afe545b2a840d0f81b86f06abd362bbe7">Canny</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_dynamic_array_template.html">CVec2dArray</a> &amp;resultPoints, <a class="el" href="class_c_dynamic_array_template.html">CVec2dArray</a> &amp;resultDirections, int nLowThreshold, int nHighThreshold)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the Canny edge detector to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the edge pixels and directions to two instances of CVec2dArray.  <a href="#afe545b2a840d0f81b86f06abd362bbe7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a19edf5fbfcdf7d1d1840d140e5d37baa">ThresholdBinarize</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, unsigned char nThreshold)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs threshold binarization to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a19edf5fbfcdf7d1d1840d140e5d37baa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a8b7459d83cd8f74d5c7bc5d44dfec8f5">ThresholdBinarizeInverse</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, unsigned char nThreshold)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs inverse threshold binarization to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a8b7459d83cd8f74d5c7bc5d44dfec8f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a65db3e105be8ca835ada1e073433d264">ThresholdFilter</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, unsigned char nThreshold)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs threhold filtering to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a65db3e105be8ca835ada1e073433d264"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#ab72a6ac0659b3ecc792bdb652b337817">ThresholdFilterInverse</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, unsigned char nThreshold)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs inverse threhold filtering to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#ab72a6ac0659b3ecc792bdb652b337817"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a9d7e2ec7f079136c91420d978a1fea29">CalculateHarrisMap</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_int_image.html">CIntImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Harris cornerness measure for every pixel in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the results to a <a class="el" href="class_c_int_image.html" title="Data structure for the representation of single channel images of the data type signed int...">CIntImage</a>.  <a href="#a9d7e2ec7f079136c91420d978a1fea29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#ac3e34751546d08c2f00ce6c223b44ef2">CalculateHarrisInterestPoints</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="struct_vec2d.html">Vec2d</a> *pInterestPoints, int nMaxPoints, float fQualityLevel=0.01f, float fMinDistance=5.0f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes interest points within a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> by applying the Harris corner detector.  <a href="#ac3e34751546d08c2f00ce6c223b44ef2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a27396e2aab4575dcd64b5588fec7f0c5">And</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage1, const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage2, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the bitwise operator AND to two instance of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a27396e2aab4575dcd64b5588fec7f0c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#afe043722c0e2b50cb661a015b644f7e0">Xor</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage1, const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage2, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the bitwise operator XOR to two instance of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#afe043722c0e2b50cb661a015b644f7e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a472f39c42aecbc10e1a3b4e648519152">Or</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage1, const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage2, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the bitwise operator OR to two instance of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a472f39c42aecbc10e1a3b4e648519152"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a48982ec62bfc4e4342a1f6c99568a5f4">Dilate</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, int nMaskSize=3, const <a class="el" href="struct_my_region.html">MyRegion</a> *pROI=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a morphological dilate operation to a binary <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a binary <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a48982ec62bfc4e4342a1f6c99568a5f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a07d829a9e1087e0cabe2d50b8cd19fd1">Erode</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, int nMaskSize=3, const <a class="el" href="struct_my_region.html">MyRegion</a> *pROI=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a morphological erode operation to a binary <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a binary <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a07d829a9e1087e0cabe2d50b8cd19fd1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#ab6d83877d812a227c3ec1552f18bc5ca">RegionGrowing</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="struct_my_region.html">MyRegion</a> &amp;resultRegion, int x, int y, int nMinimumPointsPerRegion=0, int nMaximumPointsPerRegion=0, bool bCalculateBoundingBox=true, bool bStorePixels=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a region growing on a binary <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> on the basis of one seed point and stores the computed region in a <a class="el" href="struct_my_region.html">MyRegion</a>.  <a href="#ab6d83877d812a227c3ec1552f18bc5ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a47ad2b48a7b24c4385181b47c2f45b7b">FindRegions</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pImage, <a class="el" href="_structs_8h.html#a5187b55960b912a933ac0a6c01006ec7">RegionList</a> &amp;regionList, int nMinimumPointsPerRegion=0, int nMaximumPointsPerRegion=0, bool bCalculateBoundingBox=true, bool bStorePixels=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs region growing on a binary <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>, segmenting all regions in the image.  <a href="#a47ad2b48a7b24c4385181b47c2f45b7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a6afecdfc6685222c6f80ce027cbac7c1">FindRegions</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pImage, <a class="el" href="class_c_dynamic_array_template.html">CRegionArray</a> &amp;regionList, int nMinimumPointsPerRegion=0, int nMaximumPointsPerRegion=0, bool bCalculateBoundingBox=true, bool bStorePixels=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs region growing on a binary <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>, segmenting all regions in the image.  <a href="#a6afecdfc6685222c6f80ce027cbac7c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#aef8c2053fd031ba88c291a7ff667757e">HoughTransformLines</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pVisualizationImage, <a class="el" href="_math2d_8h.html#a4739bac2860beeadc217ef0f27eec8d4">Vec2dList</a> &amp;resultLines, int nLinesToExtract, int nMinHits=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the Hough transform for straight lines on a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#aef8c2053fd031ba88c291a7ff667757e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a8d1fb3e8111d23de8077eb17555a4e33">HoughTransformCircles</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pVisualizationImage, <a class="el" href="_math3d_8h.html#aa55e7c3f7c23ce7ca441ce8235bf265e">Vec3dList</a> &amp;resultCircles, int rmin, int rmax, int nCirclesToExtract, int nMinHits=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the Hough transform for circles on a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a8d1fb3e8111d23de8077eb17555a4e33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a56ad405c66668fcf3358ce1deb35caa5">HoughTransformLines</a> (const <a class="el" href="class_c_dynamic_array_template.html">CVec2dArray</a> &amp;edgePoints, const <a class="el" href="class_c_dynamic_array_template.html">CVec2dArray</a> &amp;edgeDirections, int width, int height, int nLinesToExtract, int nMinHits, <a class="el" href="class_c_dynamic_array_template.html">CVec2dArray</a> &amp;resultLines, <a class="el" href="class_c_dynamic_array_template.html">CDynamicArrayTemplate</a>&lt; int &gt; &amp;resultHits, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pVisualizationImage=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the Hough transform for straight lines, given a list of edge points and directions.  <a href="#a56ad405c66668fcf3358ce1deb35caa5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#ae5e51f356ef046e105f1314848fced33">HoughTransformCircles</a> (const <a class="el" href="class_c_dynamic_array_template.html">CVec2dArray</a> &amp;edgePoints, const <a class="el" href="class_c_dynamic_array_template.html">CVec2dArray</a> &amp;edgeDirections, int width, int height, int rmin, int rmax, int nCirclesToExtract, int nMinHits, <a class="el" href="class_c_dynamic_array_template.html">CVec3dArray</a> &amp;resultCircles, <a class="el" href="class_c_dynamic_array_template.html">CDynamicArrayTemplate</a>&lt; int &gt; &amp;resultHits, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pVisualizationImage=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the Hough transform for circles, given a list of edge points and directions.  <a href="#ae5e51f356ef046e105f1314848fced33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a932ce4e6df317b4ba5b051fcacdfe682">ThresholdBinarize</a> (const <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *pInputImage, <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *pOutputImage, float fThreshold)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs threshold binarization to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a> and writes the result to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a>.  <a href="#a932ce4e6df317b4ba5b051fcacdfe682"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a5d72ae8d99e1fa4ca9875d7b12df1983">CalculateIntegralImage</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_int_image.html">CIntImage</a> *pIntegralImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the integral image of a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_int_image.html" title="Data structure for the representation of single channel images of the data type signed int...">CIntImage</a>.  <a href="#a5d72ae8d99e1fa4ca9875d7b12df1983"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#ad3fa049e8a6e8427010a8c83b6bc4c97">CalculateSummedAreaTable</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_int_image.html">CIntImage</a> *pSummedAreaTable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the summed area table of a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_int_image.html" title="Data structure for the representation of single channel images of the data type signed int...">CIntImage</a>.  <a href="#ad3fa049e8a6e8427010a8c83b6bc4c97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a15686fdb45f946c36b40563238e62bcc">GetAreaSum</a> (const <a class="el" href="class_c_int_image.html">CIntImage</a> *pIntegralImage, int min_x, int min_y, int max_x, int max_y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficiently computes the sum of all pixel values in a rectangular area using integral image lookups.  <a href="#a15686fdb45f946c36b40563238e62bcc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#ab34f1597ab090bb90229cf7b968fb19d">GetAreaSumNoChecks</a> (const <a class="el" href="class_c_int_image.html">CIntImage</a> *pIntegralImage, int min_x, int min_y, int max_x, int max_y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficiently computes the sum of all pixel values in a rectangular area using integral image lookups.  <a href="#ab34f1597ab090bb90229cf7b968fb19d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a6b01ed69c6911bb334d1ec6a93d18abf">GetAreaSum</a> (const <a class="el" href="class_c_int_image.html">CIntImage</a> *pIntegralImage, const <a class="el" href="struct_my_region.html">MyRegion</a> *pRegion)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficiently computes the sum of all pixel values in a rectangular area using integral image lookups.  <a href="#a6b01ed69c6911bb334d1ec6a93d18abf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#af266b7e8e93ee06018f3a11740b63aac">CalculateBinarizedSummedAreaTable</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_int_image.html">CIntImage</a> *pSummedAreaTable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the binarized summed area table of a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_int_image.html" title="Data structure for the representation of single channel images of the data type signed int...">CIntImage</a>.  <a href="#af266b7e8e93ee06018f3a11740b63aac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a2f71f42d53d9bfc555f504518bd0ce35">CalculateReverseSummedAreaTable</a> (const <a class="el" href="class_c_int_image.html">CIntImage</a> *pSummedAreaTable, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs the original image, given a summed area table, and writes the result to a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a2f71f42d53d9bfc555f504518bd0ce35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a0e1976c260bc190f097416af44b93c38">ConvertBayerPattern</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage, <a class="el" href="namespace_image_processor.html#a97586c1de02d705c7415a74bde1430ab">BayerPatternType</a> type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an 8 bit Bayer pattern <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to an RGB24 color <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a0e1976c260bc190f097416af44b93c38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#af1c16edd8ea660fce54c8de337dd2b05">Add</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage1, const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage2, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each pixel in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to the sum of the corresponding pixels in two instances of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#af1c16edd8ea660fce54c8de337dd2b05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a82429f16155ec92d5c5286415f1d11be">AddWithSaturation</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage1, const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage2, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each pixel in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to the sum of the corresponding pixels in two instances of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>, handling overflows with saturation.  <a href="#a82429f16155ec92d5c5286415f1d11be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a0e5660739b545bebb13481ad81cb01d6">Subtract</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage1, const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage2, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each pixel in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to the difference between the corresponding pixels in two instances of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a0e5660739b545bebb13481ad81cb01d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a21217df8536dbfba18d6a3cded349ecd">SubtractWithSaturation</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage1, const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage2, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each pixel in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to the difference between the corresponding pixels in two instances of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>, handling overflows with saturation.  <a href="#a21217df8536dbfba18d6a3cded349ecd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a51288e7a0402c42929d0c16252d0d428">AbsoluteDifference</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage1, const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage2, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each pixel in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to the absolute value of the difference between the corresponding pixels in two instances of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a51288e7a0402c42929d0c16252d0d428"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#ad95de4e6a0bd4f434fa9f56b082ae49e">Average</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage1, const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage2, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each pixel in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to the average of the corresponding pixels in two instances of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#ad95de4e6a0bd4f434fa9f56b082ae49e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a171d1f1c287ac0049ad8fb7fe838d57c">Min</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage1, const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage2, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each pixel in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to the minimum of the corresponding pixels in two instances of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a171d1f1c287ac0049ad8fb7fe838d57c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a1dbb2c1b690a05deba6de8907af45d1d">Max</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage1, const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pInputImage2, <a class="el" href="class_c_byte_image.html">CByteImage</a> *pOutputImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each pixel in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to the maximum of the corresponding pixels in two instances of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a1dbb2c1b690a05deba6de8907af45d1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a7a1eed4f8955b6d4cda5cdbea0befaf4">MaxValue</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum value within a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a7a1eed4f8955b6d4cda5cdbea0befaf4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#aac08c7c9378866247e45c1f0f3512247">MaxValue</a> (const <a class="el" href="class_c_short_image.html">CShortImage</a> *pImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum value within a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>.  <a href="#aac08c7c9378866247e45c1f0f3512247"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#af2a46b97b2adc374e5f1f7d8c7e7eb48">MaxValue</a> (const <a class="el" href="class_c_int_image.html">CIntImage</a> *pImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum value within a <a class="el" href="class_c_int_image.html" title="Data structure for the representation of single channel images of the data type signed int...">CIntImage</a>.  <a href="#af2a46b97b2adc374e5f1f7d8c7e7eb48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a2d356d21ca08507266ecdc5621f953ad">MinValue</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum value within a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a2d356d21ca08507266ecdc5621f953ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a865e628d7b2638d79e159f9ac1560f65">MinValue</a> (const <a class="el" href="class_c_short_image.html">CShortImage</a> *pImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum value within a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>.  <a href="#a865e628d7b2638d79e159f9ac1560f65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a4a553911babe3b0b5fb3d1ac0fb09645">MinValue</a> (const <a class="el" href="class_c_int_image.html">CIntImage</a> *pImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum value within a <a class="el" href="class_c_int_image.html" title="Data structure for the representation of single channel images of the data type signed int...">CIntImage</a>.  <a href="#a4a553911babe3b0b5fb3d1ac0fb09645"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#ada0d308b227919eeef8ef9bc03e1edd1">MinMaxValue</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pImage, unsigned char &amp;min, unsigned char &amp;max)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum and maximum value within a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#ada0d308b227919eeef8ef9bc03e1edd1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a15f7dbc458e33312d4a366e332bf8a02">MinMaxValue</a> (const <a class="el" href="class_c_short_image.html">CShortImage</a> *pImage, short &amp;min, short &amp;max)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum and maximum value within a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>.  <a href="#a15f7dbc458e33312d4a366e332bf8a02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#ad297816b76624337cf4b2e3166c0e4a1">MinMaxValue</a> (const <a class="el" href="class_c_int_image.html">CIntImage</a> *pImage, int &amp;min, int &amp;max)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum and maximum value within a <a class="el" href="class_c_int_image.html" title="Data structure for the representation of single channel images of the data type signed int...">CIntImage</a>.  <a href="#ad297816b76624337cf4b2e3166c0e4a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_processor.html#a7f4c03d300f5e35655d00e28b154b914">PixelSum</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all pixel values of a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a7f4c03d300f5e35655d00e28b154b914"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Central namespace offering various image processing routines and functions. </p>
<p>The <a class="el" href="namespace_image_processor.html" title="Central namespace offering various image processing routines and functions.">ImageProcessor</a> namespace provides various image processing functions, mostly operating on instances of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>, but also <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a> and <a class="el" href="class_c_int_image.html" title="Data structure for the representation of single channel images of the data type signed int...">CIntImage</a>, and conversion functions between these types. Among the offered functions are filtering (edge filters, smoothing filters), color segmentation, edge detection, corner detection, line/circle detection, histogram-based operators, morphological operators, arithmetic operators, logical operators, affine point operators, homography transformations, resize, thresholding and region growing. </p>
</div><hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a97586c1de02d705c7415a74bde1430ab"></a><!-- doxytag: member="ImageProcessor::BayerPatternType" ref="a97586c1de02d705c7415a74bde1430ab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_image_processor.html#a97586c1de02d705c7415a74bde1430ab">ImageProcessor::BayerPatternType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The four possible variants for Bayer pattern conversion. </p>
<p>This enum is used for specifying the variant of Bayer pattern to be processed in <a class="el" href="namespace_image_processor.html#a0e1976c260bc190f097416af44b93c38" title="Converts an 8 bit Bayer pattern CByteImage to an RGB24 color CByteImage.">ConvertBayerPattern(const CByteImage*, CByteImage*, BayerPatternType)</a>. In eBayerXY, XY describes the type of the first two pixels of the Bayer pattern in the top left corner of the image.</p>
<p>The simplest approach is to find out which is the correct one for a specific camera is to simply try all four parameters and check in the computed RGB color image, if the colors are correct (in particular red and blue). </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a97586c1de02d705c7415a74bde1430aba99299a695eae11d3915262235e6a8f44"></a><!-- doxytag: member="eBayerRG" ref="a97586c1de02d705c7415a74bde1430aba99299a695eae11d3915262235e6a8f44" args="" -->eBayerRG</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a97586c1de02d705c7415a74bde1430aba2189d8007f93129b1a6971652ec69b6e"></a><!-- doxytag: member="eBayerGR" ref="a97586c1de02d705c7415a74bde1430aba2189d8007f93129b1a6971652ec69b6e" args="" -->eBayerGR</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a97586c1de02d705c7415a74bde1430abaaca69c5c21d22afe8d1d639fd53f7e13"></a><!-- doxytag: member="eBayerBG" ref="a97586c1de02d705c7415a74bde1430abaaca69c5c21d22afe8d1d639fd53f7e13" args="" -->eBayerBG</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a97586c1de02d705c7415a74bde1430aba6fb1c443f1ebb086ca12c1d5a2dd3101"></a><!-- doxytag: member="eBayerGB" ref="a97586c1de02d705c7415a74bde1430aba6fb1c443f1ebb086ca12c1d5a2dd3101" args="" -->eBayerGB</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8h_source.html#l01669">1669</a> of file <a class="el" href="_image_processor_8h_source.html">ImageProcessor.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a51288e7a0402c42929d0c16252d0d428"></a><!-- doxytag: member="ImageProcessor::AbsoluteDifference" ref="a51288e7a0402c42929d0c16252d0d428" args="(const CByteImage *pInputImage1, const CByteImage *pInputImage2, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::AbsoluteDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets each pixel in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to the absolute value of the difference between the corresponding pixels in two instances of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>This function implements the following point operation: pOutputImage-&gt;pixels[i] = abs((int) pInputImage1-&gt;pixels[i] - (int) pInputImage2-&gt;pixels[i]).</p>
<p>Overflows cannot occur.</p>
<p>The width, height and type of pInputImage1, pInputImage2 and pOutputImage must match.<br/>
 All types of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> are supported (<a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea49137e7257d209b4b831bb271c2f69bf">CByteImage::eRGB24Split</a>).</p>
<p>As this is a point operation, there is no copy overhead if pInputImage1, pInputImage2, or pOutputImage share the same memory area.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage1</td><td>The first input image. </td></tr>
    <tr><td class="paramname">pInputImage2</td><td>The second input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l06721">6721</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d5f9f07ffef7612f0d80f501cedefb4"></a><!-- doxytag: member="ImageProcessor::AdaptFrame" ref="a6d5f9f07ffef7612f0d80f501cedefb4" args="(const CByteImage *pInputImage, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::AdaptFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets all pixels on a one pixel wide outer frame in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to the pixel values of the inner frame of a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>This function is useful for post-processing of filter responses, in particular low pass filters (smoothing filters), which do not compute values for the outer frame. For high pass filters (edge filters) it is also meaningful to call Zero(CByteImage*).</p>
<p>The outer frame consists of the top and bottom row as well as the leftmost and rightmost column. The inner frame consists of the second top most and second bottom most rows as well as the second leftmost and second rightmost columns.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be either both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a> or both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>.</p>
<p>pInputImage and pOutputImage can be pointers to the same image, with no runtime penalty.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02986">2986</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af1c16edd8ea660fce54c8de337dd2b05"></a><!-- doxytag: member="ImageProcessor::Add" ref="af1c16edd8ea660fce54c8de337dd2b05" args="(const CByteImage *pInputImage1, const CByteImage *pInputImage2, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets each pixel in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to the sum of the corresponding pixels in two instances of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>This function implements the following point operation: pOutputImage-&gt;pixels[i] = pInputImage1-&gt;pixels[i] + pInputImage2-&gt;pixels[i].</p>
<p>No saturation is performed, i.e. overflows are not handled. For instance, 200 + 56 results in 0, 200 + 57 results in 1, and so on.</p>
<p>The width, height and type of pInputImage1, pInputImage2 and pOutputImage must match.<br/>
 All types of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> are supported (<a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea49137e7257d209b4b831bb271c2f69bf">CByteImage::eRGB24Split</a>).</p>
<p>As this is a point operation, there is no copy overhead if pInputImage1, pInputImage2, or pOutputImage share the same memory area.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage1</td><td>The first input image. </td></tr>
    <tr><td class="paramname">pInputImage2</td><td>The second input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l06633">6633</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a82429f16155ec92d5c5286415f1d11be"></a><!-- doxytag: member="ImageProcessor::AddWithSaturation" ref="a82429f16155ec92d5c5286415f1d11be" args="(const CByteImage *pInputImage1, const CByteImage *pInputImage2, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::AddWithSaturation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets each pixel in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to the sum of the corresponding pixels in two instances of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>, handling overflows with saturation. </p>
<p>This function implements the following point operation: pOutputImage-&gt;pixels[i] = MY_MAX((unsigned int) pInputImage1-&gt;pixels[i] + (unsigned int) pInputImage2-&gt;pixels[i], 255).</p>
<p>Saturation is performed, i.e. overflows are handled with truncation. For instance, 200 + 56 results in 255, 200 + 57 results in 255, and so on.</p>
<p>The width, height and type of pInputImage1, pInputImage2 and pOutputImage must match.<br/>
 All types of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> are supported (<a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea49137e7257d209b4b831bb271c2f69bf">CByteImage::eRGB24Split</a>).</p>
<p>As this is a point operation, there is no copy overhead if pInputImage1, pInputImage2, or pOutputImage share the same memory area.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage1</td><td>The first input image. </td></tr>
    <tr><td class="paramname">pInputImage2</td><td>The second input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l06655">6655</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa58760b9cf3ec2765fb6221ff44aa038"></a><!-- doxytag: member="ImageProcessor::Amplify" ref="aa58760b9cf3ec2765fb6221ff44aa038" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, float fFactor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Amplify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplies each byte value of a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with a floating point factor and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>Overflows are handled by truncation.</p>
<p>The width, height and type of pInputImage and pOutputImage must match. All types of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> are supported (<a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea49137e7257d209b4b831bb271c2f69bf">CByteImage::eRGB24Split</a>).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">fFactor</td><td>The amplification factor. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l03663">3663</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a27396e2aab4575dcd64b5588fec7f0c5"></a><!-- doxytag: member="ImageProcessor::And" ref="a27396e2aab4575dcd64b5588fec7f0c5" args="(const CByteImage *pInputImage1, const CByteImage *pInputImage2, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::And </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the bitwise operator AND to two instance of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>This function implements the following point operation: pOutputImage-&gt;pixels[i] = pInputImage1-&gt;pixels[i] &amp; pInputImage2-&gt;pixels[i].</p>
<p>The width, height and type of pInputImage1, pInputImage2 and pOutputImage must match.<br/>
 All types of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> are supported (<a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea49137e7257d209b4b831bb271c2f69bf">CByteImage::eRGB24Split</a>).</p>
<p>As this is a point operation, there is no copy overhead if pInputImage1, pInputImage2, or pOutputImage share the same memory area.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage1</td><td>The first input image. </td></tr>
    <tr><td class="paramname">pInputImage2</td><td>The second input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l06569">6569</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a315140215774bd6909652ecccaefd695"></a><!-- doxytag: member="ImageProcessor::ApplyAffinePointOperation" ref="a315140215774bd6909652ecccaefd695" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, float a, float b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::ApplyAffinePointOperation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies an affine point operation to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>Applies an affine point operation with the formula a * x + b to pInputImage and writes the result to pOutputImage.<br/>
 The resulting float value is rounded to an integer value v, and min(255, max(0, v)) is written to pOutputImage.</p>
<p>The width, height and type of pInputImage and pOutputImage must match.<br/>
 All types of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> are supported (<a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea49137e7257d209b4b831bb271c2f69bf">CByteImage::eRGB24Split</a>).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">a</td><td>Coefficient for the affine point operation (factor). </td></tr>
    <tr><td class="paramname">b</td><td>Coefficient for the affine point operation (addend). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l01875">1875</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a17732d135fd1401ef60bdc84e0c72a5c"></a><!-- doxytag: member="ImageProcessor::ApplyHomography" ref="a17732d135fd1401ef60bdc84e0c72a5c" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, const Mat3d &amp;A, bool bInterpolation=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::ApplyHomography </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_mat3d.html">Mat3d</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bInterpolation</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies a homography to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>The homography can generally be formulated using homogenous coordinates as follows: <img class="formulaInl" alt="$ \left( \begin{array}{c} u' s \\ v' s \\ s \end{array} \right) = \left( \begin{array}{ccc} a_1 &amp; a_2 &amp; a_3 \\ a_4 &amp; a_5 &amp; a_6 \\ a_7 &amp; a_8 &amp; a_9 \end{array} \right) \cdot \left( \begin{array}{c} u \\ v \\ 1 \end{array} \right) $" src="form_46.png"/>. <img class="formulaInl" alt="$ a_9 = 1 $" src="form_47.png"/> is assumed without loss of generality because all real-valued multiples of the matrix define the same mapping. The mapping takes place as follows: for every (u, v) in the new image pOutputImage, the homography specified by the parameters <img class="formulaInl" alt="$a_1, \ldots, a_8$" src="form_48.png"/> computes in the original image pInputImage.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be either both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a> or both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>.</p>
<p>If pInputImage and pOutputImage share the same memory area, the input image is copied to a temporary image first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">A</td><td>The 3x3 describing the homography matrix. </td></tr>
    <tr><td class="paramname">bInterpolation</td><td>Determines whether bilinear interpolation is used or not. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l03063">3063</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae18a5f27d3bff537a082ec751a4d6585"></a><!-- doxytag: member="ImageProcessor::ApplyHomography" ref="ae18a5f27d3bff537a082ec751a4d6585" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, bool bInterpolation=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::ApplyHomography </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bInterpolation</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deprecated. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd></dd></dl>
<p>This function is deprecated. It internally calls <a class="el" href="namespace_image_processor.html#a17732d135fd1401ef60bdc84e0c72a5c" title="Applies a homography to a CByteImage and writes the result to a CByteImage.">ApplyHomography(const CByteImage*, CByteImage*, const Mat3d&amp;, bool)</a> (A.r9 is set to 1.0f); please refer to the documentation of this function for more information. </p>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l03057">3057</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad95de4e6a0bd4f434fa9f56b082ae49e"></a><!-- doxytag: member="ImageProcessor::Average" ref="ad95de4e6a0bd4f434fa9f56b082ae49e" args="(const CByteImage *pInputImage1, const CByteImage *pInputImage2, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Average </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets each pixel in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to the average of the corresponding pixels in two instances of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>This function implements the following point operation: pOutputImage-&gt;pixels[i] = (pInputImage1-&gt;pixels[i] + pInputImage2-&gt;pixels[i] + 1) &gt;&gt; 1.</p>
<p>Overflows cannot occur.</p>
<p>The width, height and type of pInputImage1, pInputImage2 and pOutputImage must match.<br/>
 All types of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> are supported (<a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea49137e7257d209b4b831bb271c2f69bf">CByteImage::eRGB24Split</a>).</p>
<p>As this is a point operation, there is no copy overhead if pInputImage1, pInputImage2, or pOutputImage share the same memory area.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage1</td><td>The first input image. </td></tr>
    <tr><td class="paramname">pInputImage2</td><td>The second input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l06743">6743</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad202012edef5f5c0d5e629c1eb4a4c46"></a><!-- doxytag: member="ImageProcessor::AverageFilter" ref="ad202012edef5f5c0d5e629c1eb4a4c46" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, int nMaskSize=3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::AverageFilter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaskSize</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies an average filter to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>Applies an average filter (low pass filter) of size nMaskSize x nMaskSize to pInputImage and writes the result to pOutputImage.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<p>If pInputImage and pOutputImage share the same memory area, the input image is copied to a temporary image first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">nMaskSize</td><td>Determines the side length of the window whose interior points are used for computing the average. Must be an odd integer greater than 2. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l00634">634</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af266b7e8e93ee06018f3a11740b63aac"></a><!-- doxytag: member="ImageProcessor::CalculateBinarizedSummedAreaTable" ref="af266b7e8e93ee06018f3a11740b63aac" args="(const CByteImage *pInputImage, CIntImage *pSummedAreaTable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::CalculateBinarizedSummedAreaTable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_int_image.html">CIntImage</a> *&#160;</td>
          <td class="paramname"><em>pSummedAreaTable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the binarized summed area table of a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_int_image.html" title="Data structure for the representation of single channel images of the data type signed int...">CIntImage</a>. </p>
<p>In the binarized summed area table, each value is the count of all non-zero values in pInputImage left and above of it, i.e. <img class="formulaInl" alt="$ {\rm BinarizedSummedAreaTable}_{x, y} = \sum_{i=0}^x \sum_{j=0}^y min(1, I_{i, j}) $" src="form_66.png"/>.</p>
<p>This function is useful if the image size is so large that overflows can occur when applying <a class="el" href="namespace_image_processor.html#a5d72ae8d99e1fa4ca9875d7b12df1983" title="Calculates the integral image of a grayscale CByteImage and writes the result to a CIntImage...">CalculateIntegralImage(const CByteImage*, CIntImage*)</a> (resp. <a class="el" href="namespace_image_processor.html#ad3fa049e8a6e8427010a8c83b6bc4c97" title="Calculates the summed area table of a grayscale CByteImage and writes the result to a CIntImage...">CalculateSummedAreaTable(const CByteImage*, CIntImage*)</a>). For example, the maximum value for a 1024x768 image is 1024 * 768 * 255 = 200540160 &lt; 2147483647 = INT_MAX, which is ok. Overflows will occur approximately for images with more than 8 megapixels.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. Must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>. </td></tr>
    <tr><td class="paramname">pSummedAreaTable</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l05861">5861</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0804f830310cb96b9dd891c7e8122c6c"></a><!-- doxytag: member="ImageProcessor::CalculateGradientImage" ref="a0804f830310cb96b9dd891c7e8122c6c" args="(const CByteImage *pInputImage, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::CalculateGradientImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies a combined simple gradient filter for both x- and y-direction to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and stores the result in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>Applies a 1x3 gradient operator of the form (-1 0 1) and a 3x1 gradient operator of the form (1 0 -1)^T for each pixel of pInputImage, resulting in the values gx and gy, and writes the result min(255, max(gx, gy)) to pOutputImage. In the case of color images, each channel is processed independently.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be either both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a> or both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>. In the case of <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>, each channel is processed independently and for each pixel, the maximum over all channels is taken.</p>
<p>If pInputImage and pOutputImage share the same memory area, the input image is copied to a temporary image first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l01211">1211</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a95092a5341161a3cd05343664d963b71"></a><!-- doxytag: member="ImageProcessor::CalculateGradientImageBinary" ref="a95092a5341161a3cd05343664d963b71" args="(const CByteImage *pInputImage, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::CalculateGradientImageBinary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates a gradient image for a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>, for the special case of binary images. </p>
<p>Calculates a gradient image for a binary image stored in pInputImage and writes the result to pOutputImage. This function implements an optimized version of <img class="formulaInl" alt="$ I_g(x,y) = \max(|I(x+1,y) - I(x,y)|, |I(x,y+1)-I(x,y)|)$" src="form_43.png"/> for the special case of binary images.</p>
<p>Note that the gradient locations are in general displaced with an offset of (-0.5, -0.5) pixels with respect to the true edge locations in the input image. If subpixel accuracy is needed, it is recommended to filter the image with a Gaussian filter first (e.g. <a class="el" href="namespace_image_processor.html#ae58234b3f065a061844c8f7139f57be3" title="Applies a 5x5 Gaussian filter to a CByteImage and writes the result to a CByteImage.">GaussianSmooth5x5(const CByteImage*, CByteImage*)</a>) and then apply a general edge filter (e.g. CalculateGradientImageSobel(const CByteImage*, CShortImage*)) or an edge detector (e.g. <a class="el" href="namespace_image_processor.html#afe545b2a840d0f81b86f06abd362bbe7" title="Applies the Canny edge detector to a CByteImage and writes the edge pixels and directions to two inst...">Canny(const CByteImage*, CVec2dArray&amp;, CVec2dArray&amp;, int, int)</a>, which directly outputs edge points with subpixel accuracy). The width and height of pInputImage and pOutputImage must match.</p>
<p>pInputImage and pOutputImage must be both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a> and must contain binary images, i.e. contain only two different values: 0 and a non-zero value (usually 255 for visualization purposes).</p>
<p>If pInputImage and pOutputImage share the same memory area, the input image is copied to a temporary image first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l01279">1279</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a42292832d673ef5acca4b6634fe975a4"></a><!-- doxytag: member="ImageProcessor::CalculateGradientImagePrewitt" ref="a42292832d673ef5acca4b6634fe975a4" args="(const CByteImage *pInputImage, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::CalculateGradientImagePrewitt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies a combined Prewitt filter for both x- and y-direction to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and stores the result in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>Applies a PrewittX and a PrewittY operator for each pixel of pInputImage, resulting in the values gx and gy, and writes the result min(255, max(gx, gy)) to pOutputImage.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<p>If pInputImage and pOutputImage share the same memory area, the input image is copied to a temporary image first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l01107">1107</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaebaca4811777943c3d377ed1aab7354"></a><!-- doxytag: member="ImageProcessor::CalculateGradientImageSobel" ref="aaebaca4811777943c3d377ed1aab7354" args="(const CByteImage *pInputImage, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::CalculateGradientImageSobel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies a combined Sobel filter for both x- and y-direction to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and stores the result in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>Applies a SobelX and a SobelY operator for each pixel of pInputImage, resulting in the values gx and gy, and writes the result min(255, max(gx, gy)) to pOutputImage.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<p>If pInputImage and pOutputImage share the same memory area, the input image is copied to a temporary image first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l01159">1159</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac3e34751546d08c2f00ce6c223b44ef2"></a><!-- doxytag: member="ImageProcessor::CalculateHarrisInterestPoints" ref="ac3e34751546d08c2f00ce6c223b44ef2" args="(const CByteImage *pInputImage, Vec2d *pInterestPoints, int nMaxPoints, float fQualityLevel=0.01f, float fMinDistance=5.0f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ImageProcessor::CalculateHarrisInterestPoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vec2d.html">Vec2d</a> *&#160;</td>
          <td class="paramname"><em>pInterestPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaxPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fQualityLevel</em> = <code>0.01f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fMinDistance</em> = <code>5.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes interest points within a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> by applying the Harris corner detector. </p>
<p>Uses the function <a class="el" href="namespace_image_processor.html#a9d7e2ec7f079136c91420d978a1fea29" title="Calculates the Harris cornerness measure for every pixel in a CByteImage and writes the results to a ...">CalculateHarrisMap(const CByteImage*, CIntImage*)</a> to compute a cornerness map. nMaxPoints maxima are searched, also applying a non maximum suppression, and sorting the candiates in decreasing order.</p>
<p>The interest points must fulfill the quality constraint specified by fQualityLevel. Two interest points must have a distance of at least fMinDistance.</p>
<p>All interest points are computed with pixel accuracy.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. Must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>. </td></tr>
    <tr><td class="paramname">pInterestPoints</td><td>The memory area for the interest points to be computed. Must provide space for at least nMaxPoints instances of <a class="el" href="struct_vec2d.html" title="Data structure for the representation of a 2D vector.">Vec2d</a>. </td></tr>
    <tr><td class="paramname">nMaxPoints</td><td>The maximum number of interest points to determine. </td></tr>
    <tr><td class="paramname">fQualityLevel</td><td>The algorithm determines the interest point with the maximum cornerness value first. fQualityLevel is multiplied with the maximum cornerness value, yielding a minimum quality constraint. </td></tr>
    <tr><td class="paramname">fMinDistance</td><td>The minimum Euclidean distance two computed interest points must have. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of interest points found. If an error occurs -1 is returned. </dd></dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l06480">6480</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9d7e2ec7f079136c91420d978a1fea29"></a><!-- doxytag: member="ImageProcessor::CalculateHarrisMap" ref="a9d7e2ec7f079136c91420d978a1fea29" args="(const CByteImage *pInputImage, CIntImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::CalculateHarrisMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_int_image.html">CIntImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the Harris cornerness measure for every pixel in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the results to a <a class="el" href="class_c_int_image.html" title="Data structure for the representation of single channel images of the data type signed int...">CIntImage</a>. </p>
<p>The cornerness value is defined as <img class="formulaInl" alt="$ c = det(C) - \kappa \cdot {trace(C)}^2 $" src="form_50.png"/> where C is the covariance matrix for a given pixel location and observation windows and <img class="formulaInl" alt="$ \kappa = 0.04 $" src="form_51.png"/>. As observation window a 3x3 windows is used.</p>
<p>The width and height of pInputImage and pOutputImage must match. pInputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. Must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l06373">6373</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5d72ae8d99e1fa4ca9875d7b12df1983"></a><!-- doxytag: member="ImageProcessor::CalculateIntegralImage" ref="a5d72ae8d99e1fa4ca9875d7b12df1983" args="(const CByteImage *pInputImage, CIntImage *pIntegralImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::CalculateIntegralImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_int_image.html">CIntImage</a> *&#160;</td>
          <td class="paramname"><em>pIntegralImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the integral image of a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_int_image.html" title="Data structure for the representation of single channel images of the data type signed int...">CIntImage</a>. </p>
<p>In the integral image, each value is the sum of all values in pInputImage left and above of it, i.e. <img class="formulaInl" alt="$ {\rm IntegralImage}_{x, y} = \sum_{i=0}^x \sum_{j=0}^y I_{i, j} $" src="form_62.png"/>.</p>
<p>If the input image size is so large that overflows can occur, <a class="el" href="namespace_image_processor.html#af266b7e8e93ee06018f3a11740b63aac" title="Calculates the binarized summed area table of a grayscale CByteImage and writes the result to a CIntI...">CalculateBinarizedSummedAreaTable(const CByteImage*, CIntImage*)</a> should be caled. For example, the maximum value for a 1024x768 image is 1024 * 768 * 255 = 200540160 &lt; 2147483647 = INT_MAX, which is ok. Overflows will occur approximately for images with more than 8 megapixels.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. Must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>: </td></tr>
    <tr><td class="paramname">pIntegralImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l05808">5808</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2f71f42d53d9bfc555f504518bd0ce35"></a><!-- doxytag: member="ImageProcessor::CalculateReverseSummedAreaTable" ref="a2f71f42d53d9bfc555f504518bd0ce35" args="(const CIntImage *pSummedAreaTable, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::CalculateReverseSummedAreaTable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_int_image.html">CIntImage</a> *&#160;</td>
          <td class="paramname"><em>pSummedAreaTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reconstructs the original image, given a summed area table, and writes the result to a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>The original image pSummedAreaTable was computed for (applying <a class="el" href="namespace_image_processor.html#ad3fa049e8a6e8427010a8c83b6bc4c97" title="Calculates the summed area table of a grayscale CByteImage and writes the result to a CIntImage...">CalculateSummedAreaTable(const CByteImage*, CIntImage*)</a> or <a class="el" href="namespace_image_processor.html#a5d72ae8d99e1fa4ca9875d7b12df1983" title="Calculates the integral image of a grayscale CByteImage and writes the result to a CIntImage...">CalculateIntegralImage(const CByteImage*, CIntImage*)</a>) is reconstructed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pSummedAreaTable</td><td>The summed area table (resp. integral image). </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The result image (reconstructed image). Must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l05910">5910</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac54eadd19d9520aba535313eb184b76c"></a><!-- doxytag: member="ImageProcessor::CalculateSaturationImage" ref="ac54eadd19d9520aba535313eb184b76c" args="(const CByteImage *pInputImage, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::CalculateSaturationImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the saturation image for an RGB <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>Computes the saturation image (S-channel of the HSV image) of pInputImage and writes the result to pOutputImage.</p>
<p>The width and height of pInputImage and pOutputImage must match.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. Must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. Must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l03687">3687</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad3fa049e8a6e8427010a8c83b6bc4c97"></a><!-- doxytag: member="ImageProcessor::CalculateSummedAreaTable" ref="ad3fa049e8a6e8427010a8c83b6bc4c97" args="(const CByteImage *pInputImage, CIntImage *pSummedAreaTable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::CalculateSummedAreaTable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_int_image.html">CIntImage</a> *&#160;</td>
          <td class="paramname"><em>pSummedAreaTable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the summed area table of a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_int_image.html" title="Data structure for the representation of single channel images of the data type signed int...">CIntImage</a>. </p>
<p>This function performs the same as CalculateIntegralImage - two different names are available only to simplify searching for the functionality.</p>
<p>In the summed area table each value is the sum of all values in pInputImage left and above of it, i.e. <img class="formulaInl" alt="$ {\rm SummedAreaTable}_{x, y} = \sum_{i=0}^x \sum_{j=0}^y I_{i, j} $" src="form_63.png"/>.</p>
<p>If the input image size is so large that overflows can occur, <a class="el" href="namespace_image_processor.html#af266b7e8e93ee06018f3a11740b63aac" title="Calculates the binarized summed area table of a grayscale CByteImage and writes the result to a CIntI...">CalculateBinarizedSummedAreaTable(const CByteImage*, CIntImage*)</a> should be caled. For example, the maximum value for a 1024x768 image is 1024 * 768 * 255 = 200540160 &lt; 2147483647 = INT_MAX, which is ok. Overflows will occur approximately for images with more than 8 megapixels.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. Must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>. </td></tr>
    <tr><td class="paramname">pSummedAreaTable</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l05849">5849</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2ae90a1ded17ef4234ea928aa0992e95"></a><!-- doxytag: member="ImageProcessor::Canny" ref="a2ae90a1ded17ef4234ea928aa0992e95" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, int nLowThreshold, int nHighThreshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Canny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLowThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nHighThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the Canny edge detector to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>In pOutputImage, edge pixels will be encoded with the value 255, all other pixels with the value 0.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">nLowThreshold</td><td>The low threshold for the Canny edge detector. </td></tr>
    <tr><td class="paramname">nHighThreshold</td><td>The high threshold for the Canny edge detector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l06054">6054</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afe545b2a840d0f81b86f06abd362bbe7"></a><!-- doxytag: member="ImageProcessor::Canny" ref="afe545b2a840d0f81b86f06abd362bbe7" args="(const CByteImage *pInputImage, CVec2dArray &amp;resultPoints, CVec2dArray &amp;resultDirections, int nLowThreshold, int nHighThreshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Canny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_dynamic_array_template.html">CVec2dArray</a> &amp;&#160;</td>
          <td class="paramname"><em>resultPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_dynamic_array_template.html">CVec2dArray</a> &amp;&#160;</td>
          <td class="paramname"><em>resultDirections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLowThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nHighThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the Canny edge detector to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the edge pixels and directions to two instances of CVec2dArray. </p>
<p>This function computes edge pixels with subpixel accuracy as well as the edge direction for each edge pixel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. Must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>. </td></tr>
    <tr><td class="paramname">resultPoints</td><td>Result list containing edge points with subpixel accuracy. </td></tr>
    <tr><td class="paramname">resultDirections</td><td>Result list containing gradient directions. Entries with the same index match between resultPoints and resultDirections. </td></tr>
    <tr><td class="paramname">nLowThreshold</td><td>The low threshold for the Canny edge detector. </td></tr>
    <tr><td class="paramname">nHighThreshold</td><td>The high threshold for the Canny edge detector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l06243">6243</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e1976c260bc190f097416af44b93c38"></a><!-- doxytag: member="ImageProcessor::ConvertBayerPattern" ref="a0e1976c260bc190f097416af44b93c38" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, BayerPatternType type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::ConvertBayerPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BayerPatternType&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts an 8 bit Bayer pattern <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to an RGB24 color <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>This function computes the RGB24 color image for a given 8 bit grayscale image containing the raw data of a Bayer pattern.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. Must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. Must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>. </td></tr>
    <tr><td class="paramname">type</td><td>The type of Bayer pattern assumed for processing. See BayerPatternType for further information. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l07086">7086</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8716bb2c22c678699c4cb3703cc9f2a5"></a><!-- doxytag: member="ImageProcessor::ConvertImage" ref="a8716bb2c22c678699c4cb3703cc9f2a5" args="(const CFloatMatrix *pInputImage, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::ConvertImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a> to a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>Converts pInputImage to pOutputImage by linearly mapping the interval [min, max] to [0, 255], where min/max are the minimum/maximum value in pInputImage. This conversion can cause a loss of information.<br/>
 If pInputImage is homogeneous, the values of pOutputImage are all set to zero.</p>
<p>The column count of pInputImage must match the width of pOutputImage and the row count of pInputImage must match the height of pOutputImage.<br/>
 pOutputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02371">2371</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2c4640c7060531d9e7bcac387b5349b1"></a><!-- doxytag: member="ImageProcessor::ConvertImage" ref="a2c4640c7060531d9e7bcac387b5349b1" args="(const CIntImage *pInputImage, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::ConvertImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_int_image.html">CIntImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a <a class="el" href="class_c_int_image.html" title="Data structure for the representation of single channel images of the data type signed int...">CIntImage</a> to a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>Converts pInputImage to pOutputImage by linearly mapping the interval [min, max] to [0, 255], where min/max are the minimum/maximum value in pInputImage. This conversion can cause a loss of information.<br/>
 If pInputImage is homogeneous, the values of pOutputImage are all set to zero.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pOutputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02493">2493</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aee2bfde18b4d47cc961411236f962bf7"></a><!-- doxytag: member="ImageProcessor::ConvertImage" ref="aee2bfde18b4d47cc961411236f962bf7" args="(const CByteImage *pInputImage, CIntImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::ConvertImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_int_image.html">CIntImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to a <a class="el" href="class_c_int_image.html" title="Data structure for the representation of single channel images of the data type signed int...">CIntImage</a>. </p>
<p>Converts pInputImage to pOutputImage by casting the unsigned char values to int.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02477">2477</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca48232f18c62f07c33d972fba58f5fb"></a><!-- doxytag: member="ImageProcessor::ConvertImage" ref="aca48232f18c62f07c33d972fba58f5fb" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, bool bFast=false, const MyRegion *pROI=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::ConvertImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bFast</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_my_region.html">MyRegion</a> *&#160;</td>
          <td class="paramname"><em>pROI</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to an RGB <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> image and vice versa. </p>
<p>The RGB image can be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a> or <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea49137e7257d209b4b831bb271c2f69bf">CByteImage::eRGB24Split</a>.<br/>
 If pInputImage-&gt;type and pOutputImage-&gt;type are equal, the input image is copied to the output image.</p>
<p>The width and height of pInputImage and pOutputImage must match.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">bFast</td><td>If true, a fast bit shift implementation of g = (r + 2 * g + b + 2) / 4 is used, otherwise an approximation of 0.299 * r + 0.587 * g + 0.114 * b using integer arithmetics is used. </td></tr>
    <tr><td class="paramname">pROI</td><td>Describes the area containing the pixels which shall be converted. If pROI is 0, then the whole image is processed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02013">2013</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0f5e64ac6135385f6a6a551e6d603e5b"></a><!-- doxytag: member="ImageProcessor::ConvertImage" ref="a0f5e64ac6135385f6a6a551e6d603e5b" args="(const CFloatImage *pInputImage, CByteImage *pOutputImage, bool equalize=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::ConvertImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_float_image.html">CFloatImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>equalize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a <a class="el" href="class_c_float_image.html" title="Data structure for the representation of any image type (arbitrary number of channels) using the data...">CFloatImage</a> to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>Converts pInputImage to pOutputImage by casting the float values to unsigned char.</p>
<p>The dimension and channel number of pInputImage must match the dimension channel number of pOutputImage.<br/>
</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">equalize</td><td>If set to true, the input values are equalized. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02231">2231</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ace8d9db64bf4b5ebd04711f4efb1cecd"></a><!-- doxytag: member="ImageProcessor::ConvertImage" ref="ace8d9db64bf4b5ebd04711f4efb1cecd" args="(const CByteImage *pInputImage, CFloatMatrix *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::ConvertImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a>. </p>
<p>Converts pInputImage to pOutputImage by casting the unsigned char values to float.</p>
<p>The width of pInputImage must match the column count of pOutputImage and the height of pInputImage must match the row count of pOutputImage.<br/>
 pInputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02409">2409</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a53d89906c569cf675efbb413012efce0"></a><!-- doxytag: member="ImageProcessor::ConvertImage" ref="a53d89906c569cf675efbb413012efce0" args="(const CShortImage *pInputImage, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::ConvertImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_short_image.html">CShortImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a> to a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>Converts pInputImage to pOutputImage by linearly mapping the interval [min, max] to [0, 255], where min/max are the minimum/maximum value in pInputImage. This conversion can cause a loss of information.<br/>
 If pInputImage is homogeneous, the values of pOutputImage are all set to zero.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pOutputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02425">2425</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a148f646ee2651dc3ab33bcc4de0c1042"></a><!-- doxytag: member="ImageProcessor::ConvertImage" ref="a148f646ee2651dc3ab33bcc4de0c1042" args="(const CByteImage *pInputImage, CFloatImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::ConvertImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_float_image.html">CFloatImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to a <a class="el" href="class_c_float_image.html" title="Data structure for the representation of any image type (arbitrary number of channels) using the data...">CFloatImage</a>. </p>
<p>Converts pInputImage to pOutputImage by casting the unsigned char values to float.</p>
<p>The dimension and channel number of pInputImage must match the dimension channel number of pOutputImage.<br/>
</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02333">2333</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a841ce8bfce0143c3aed02733f31aacf0"></a><!-- doxytag: member="ImageProcessor::ConvertImage" ref="a841ce8bfce0143c3aed02733f31aacf0" args="(const CByteImage *pInputImage, CShortImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::ConvertImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_short_image.html">CShortImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>. </p>
<p>Converts pInputImage to pOutputImage by casting the unsigned char values to short.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02461">2461</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a07707c758ade7627050600d3f56b75a2"></a><!-- doxytag: member="ImageProcessor::ConvertMatrix" ref="a07707c758ade7627050600d3f56b75a2" args="(const CFloatMatrix *pInputImage, CDoubleMatrix *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::ConvertMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_double_matrix.html">CDoubleMatrix</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a> to a <a class="el" href="class_c_double_matrix.html" title="Data structure for the representation of a matrix of values of the data type double.">CDoubleMatrix</a>. </p>
<p>Converts pInputImage to pOutputImage by casting the float values to double.</p>
<p>The row count and the column count of pInputImage and pOutputImage must match.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02530">2530</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad89ae984474f2647205adea1f32b78d9"></a><!-- doxytag: member="ImageProcessor::ConvertMatrix" ref="ad89ae984474f2647205adea1f32b78d9" args="(const CDoubleMatrix *pInputImage, CFloatMatrix *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::ConvertMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_double_matrix.html">CDoubleMatrix</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a <a class="el" href="class_c_double_matrix.html" title="Data structure for the representation of a matrix of values of the data type double.">CDoubleMatrix</a> to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a>. </p>
<p>Converts pInputImage to pOutputImage by casting the double values to float. This conversion can cause a loss of precision.</p>
<p>The row count and the column count of pInputImage and pOutputImage must match.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02546">2546</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa5ca4cff5ad86826be9735e8b1f0c07b"></a><!-- doxytag: member="ImageProcessor::CopyFrame" ref="aa5ca4cff5ad86826be9735e8b1f0c07b" args="(const CByteImage *pInputImage, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::CopyFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies all pixels on a one pixel wide frame from one <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>The frame consists of the top and bottom row as well as the leftmost and rightmost column.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be either both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a> or both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02936">2936</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a243bcd983a82e63ca4aa97ca2a72af58"></a><!-- doxytag: member="ImageProcessor::CopyImage" ref="a243bcd983a82e63ca4aa97ca2a72af58" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, const MyRegion *pROI=0, bool bUseSameSize=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::CopyImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_my_region.html">MyRegion</a> *&#160;</td>
          <td class="paramname"><em>pROI</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUseSameSize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies one <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to another. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">pROI</td><td>Describes the area containing the pixels which shall be copied. If pROI is 0, then the full image is copied. </td></tr>
    <tr><td class="paramname">bUseSameSize</td><td>This parameter is only relevant if pROI is not 0. If bUseSameSize is true, the width and height of pInputImage and pOutputImage must match. Otherwise, the dimensions of pROI and pOutputImage must match, i.e. pROI-&gt;max_x - pROI-&gt;min_x + 1 = pOutputImage-&gt;width and pROI-&gt;max_y - pROI-&gt;min_y + 1 = pOutputImage-&gt;height. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02563">2563</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a72f046becee4a6661d2651d7b6812785"></a><!-- doxytag: member="ImageProcessor::CopyImage" ref="a72f046becee4a6661d2651d7b6812785" args="(const CShortImage *pInputImage, CShortImage *pOutputImage, const MyRegion *pROI=0, bool bUseSameSize=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::CopyImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_short_image.html">CShortImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_short_image.html">CShortImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_my_region.html">MyRegion</a> *&#160;</td>
          <td class="paramname"><em>pROI</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUseSameSize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies one <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a> to another. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">pROI</td><td>Describes the area containing the pixels which shall be copied. If pROI is 0, then the full image is copied. </td></tr>
    <tr><td class="paramname">bUseSameSize</td><td>This parameter is only relevant if pROI is not 0. If bUseSameSize is true, the width and height of pInputImage and pOutputImage must match. Otherwise, the dimensions of pROI and pOutputImage must match, i.e. pROI-&gt;max_x - pROI-&gt;min_x + 1 = pOutputImage-&gt;width and pROI-&gt;max_y - pROI-&gt;min_y + 1 = pOutputImage-&gt;height. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02682">2682</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae68350981446bf610a01cfc23e4b77f6"></a><!-- doxytag: member="ImageProcessor::CopyMatrix" ref="ae68350981446bf610a01cfc23e4b77f6" args="(const CFloatMatrix *pInputImage, CFloatMatrix *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::CopyMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies one <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a> to another. </p>
<p>The row count and the column count of pInputImage and pOutputImage must match.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02760">2760</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af340a142efb40efc254570bf2dd7793d"></a><!-- doxytag: member="ImageProcessor::CopyMatrix" ref="af340a142efb40efc254570bf2dd7793d" args="(const CDoubleMatrix *pInputImage, CDoubleMatrix *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::CopyMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_double_matrix.html">CDoubleMatrix</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_double_matrix.html">CDoubleMatrix</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies one <a class="el" href="class_c_double_matrix.html" title="Data structure for the representation of a matrix of values of the data type double.">CDoubleMatrix</a> to another. </p>
<p>The row count and the column count of pInputImage and pOutputImage must match.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02771">2771</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab54781247aa0baee84e400c52d05f454"></a><!-- doxytag: member="ImageProcessor::DetermineAffineTransformation" ref="ab54781247aa0baee84e400c52d05f454" args="(const Vec2d *pSourcePoints, const Vec2d *pTargetPoints, int nPoints, float &amp;a1, float &amp;a2, float &amp;a3, float &amp;a4, float &amp;a5, float &amp;a6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::DetermineAffineTransformation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_vec2d.html">Vec2d</a> *&#160;</td>
          <td class="paramname"><em>pSourcePoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vec2d.html">Vec2d</a> *&#160;</td>
          <td class="paramname"><em>pTargetPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>a6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deprecated. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd></dd></dl>
<p>This function is deprecated. It calls <a class="el" href="namespace_linear_algebra.html#ac69fc0fe6bd705f6ac74ca0a2047a1d9" title="Determines an affine transformation based on a set of 2d-2d point correspondences.">LinearAlgebra::DetermineAffineTransformation</a>; please refer to the documentation of this function for more information. </p>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l05020">5020</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca0a8170ac143fbdcfd3515f2b94f353"></a><!-- doxytag: member="ImageProcessor::DetermineHomography" ref="aca0a8170ac143fbdcfd3515f2b94f353" args="(const Vec2d *pSourcePoints, const Vec2d *pTargetPoints, int nPoints, float &amp;a1, float &amp;a2, float &amp;a3, float &amp;a4, float &amp;a5, float &amp;a6, float &amp;a7, float &amp;a8)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::DetermineHomography </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_vec2d.html">Vec2d</a> *&#160;</td>
          <td class="paramname"><em>pSourcePoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vec2d.html">Vec2d</a> *&#160;</td>
          <td class="paramname"><em>pTargetPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>a8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deprecated. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd></dd></dl>
<p>This function is deprecated. It internally calls <a class="el" href="namespace_linear_algebra.html#a796e7ae183584b9f891b4ee6e08e5062" title="Determines a homography based on a set of 2d-2d point correspondences.">LinearAlgebra::DetermineHomography</a>; please refer to the documentation of this function for more information. </p>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l05004">5004</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a48982ec62bfc4e4342a1f6c99568a5f4"></a><!-- doxytag: member="ImageProcessor::Dilate" ref="a48982ec62bfc4e4342a1f6c99568a5f4" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, int nMaskSize=3, const MyRegion *pROI=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Dilate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaskSize</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_my_region.html">MyRegion</a> *&#160;</td>
          <td class="paramname"><em>pROI</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies a morphological dilate operation to a binary <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a binary <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>A morphological dilate operation with a squared structure element is applied. The input image is assumed to encode background with the value 0 and foreground with 255. The output image will be encoded in the same way.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<p>If pInputImage and pOutputImage share the same memory area, the input image is copied to a temporary image first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">nMaskSize</td><td>Determines the size of the structure element. A squared structure element of size nMaskSize x nMaskSize is used. nMaskSize must be an uneven number greater or equal 3. </td></tr>
    <tr><td class="paramname">pROI</td><td>Describes the area containing the pixels on which the operation shall be executed. If pROI is 0, then the whole image is processed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l01575">1575</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a07d829a9e1087e0cabe2d50b8cd19fd1"></a><!-- doxytag: member="ImageProcessor::Erode" ref="a07d829a9e1087e0cabe2d50b8cd19fd1" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, int nMaskSize=3, const MyRegion *pROI=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Erode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaskSize</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_my_region.html">MyRegion</a> *&#160;</td>
          <td class="paramname"><em>pROI</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies a morphological erode operation to a binary <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a binary <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>A morphological erode operation with a squared structure element is applied. The input image is assumed to encode background with the value 0 and foreground with 255. The output image will be encoded in the same way.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<p>If pInputImage and pOutputImage share the same memory area, the input image is copied to a temporary image first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">nMaskSize</td><td>Determines the size of the structure element. A squared structure element of size nMaskSize x nMaskSize is used. nMaskSize must be an uneven number greater or equal 3. </td></tr>
    <tr><td class="paramname">pROI</td><td>Describes the area containing the pixels on which the operation shall be executed. If pROI is 0, then the whole image is processed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l01702">1702</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a47ad2b48a7b24c4385181b47c2f45b7b"></a><!-- doxytag: member="ImageProcessor::FindRegions" ref="a47ad2b48a7b24c4385181b47c2f45b7b" args="(const CByteImage *pImage, RegionList &amp;regionList, int nMinimumPointsPerRegion=0, int nMaximumPointsPerRegion=0, bool bCalculateBoundingBox=true, bool bStorePixels=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::FindRegions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_structs_8h.html#a5187b55960b912a933ac0a6c01006ec7">RegionList</a> &amp;&#160;</td>
          <td class="paramname"><em>regionList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMinimumPointsPerRegion</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaximumPointsPerRegion</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCalculateBoundingBox</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bStorePixels</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs region growing on a binary <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>, segmenting all regions in the image. </p>
<p>It is recommended to use the function <a class="el" href="namespace_image_processor.html#a6afecdfc6685222c6f80ce027cbac7c1" title="Performs region growing on a binary CByteImage, segmenting all regions in the image.">FindRegions(const CByteImage*, CRegionArray&amp;, int, int, bool, bool)</a> instead. The only difference is the type of the parameter regionList, which is a std::vector&lt;MyRegion&gt; here and a CDynamicArrayTemplate&lt;MyRegion&gt; in the other case, which is more efficient.</p>
<p>This function chooses every foreground pixel as seed point and performs a region growing (4-connectivity) by calling the function <a class="el" href="namespace_image_processor.html#ab6d83877d812a227c3ec1552f18bc5ca" title="Performs a region growing on a binary CByteImage on the basis of one seed point and stores the comput...">RegionGrowing(const CByteImage*, MyRegion&amp;, int, int, int, int, bool, bool)</a>. Already visited pixels are marked so that only not unvisited pixels can serve as seed points.</p>
<p>The input image is assumed to encode background with the value 0 and foreground with the value 255.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pImage</td><td>The input image. Must be a binary image of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>. </td></tr>
    <tr><td class="paramname">regionList</td><td>The list of regions. RegionList is a typedef for std::vector&lt;MyRegion&gt;. </td></tr>
    <tr><td class="paramname">nMinimumPointsPerRegion</td><td>Specifies the minimum number of pixels the region must contain. The default value nMinimumPointsPerRegion = 0 means that no lower bound is checked. </td></tr>
    <tr><td class="paramname">nMaximumPointsPerRegion</td><td>Specifies the maximum number of pixels the region may contain. The default value nMaximumPointsPerRegion = 0 means that no upper bound is checked. </td></tr>
    <tr><td class="paramname">bCalculateBoundingBox</td><td>Calculate bounding box (members min_x, min_y, max_x, max_y, ratio of <a class="el" href="struct_my_region.html">MyRegion</a>) or not. Setting bCalculateBoundingBox to false saves computation time. </td></tr>
    <tr><td class="paramname">bStorePixels</td><td>Store pixels belonging to the region in the member <a class="el" href="struct_my_region.html#a23d649b05d07bf26eed5b94f6a2bb2be">MyRegion::pPixels</a>. Memory is handled automatically (allocation/deletion). Setting bStorePixels to false saves computation time. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l04190">4190</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6afecdfc6685222c6f80ce027cbac7c1"></a><!-- doxytag: member="ImageProcessor::FindRegions" ref="a6afecdfc6685222c6f80ce027cbac7c1" args="(const CByteImage *pImage, CRegionArray &amp;regionList, int nMinimumPointsPerRegion=0, int nMaximumPointsPerRegion=0, bool bCalculateBoundingBox=true, bool bStorePixels=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::FindRegions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_dynamic_array_template.html">CRegionArray</a> &amp;&#160;</td>
          <td class="paramname"><em>regionList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMinimumPointsPerRegion</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaximumPointsPerRegion</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCalculateBoundingBox</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bStorePixels</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs region growing on a binary <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>, segmenting all regions in the image. </p>
<p>This function chooses every foreground pixel as seed point and performs a region growing (4-connectivity) by calling the function <a class="el" href="namespace_image_processor.html#ab6d83877d812a227c3ec1552f18bc5ca" title="Performs a region growing on a binary CByteImage on the basis of one seed point and stores the comput...">RegionGrowing(const CByteImage*, MyRegion&amp;, int, int, int, int, bool, bool)</a>. Already visited pixels are marked so that only not unvisited pixels can serve as seed points.</p>
<p>The input image is assumed to encode background with the value 0 and foreground with the value 255.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pImage</td><td>The input image. Must be a binary image of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>. </td></tr>
    <tr><td class="paramname">regionList</td><td>The list of regions. CRegionArray is a typedef for CDynamicArrayTemplate&lt;MyRegion&gt;. </td></tr>
    <tr><td class="paramname">nMinimumPointsPerRegion</td><td>Specifies the minimum number of pixels the region must contain. The default value nMinimumPointsPerRegion = 0 means that no lower bound is checked. </td></tr>
    <tr><td class="paramname">nMaximumPointsPerRegion</td><td>Specifies the maximum number of pixels the region may contain. The default value nMaximumPointsPerRegion = 0 means that no upper bound is checked. </td></tr>
    <tr><td class="paramname">bCalculateBoundingBox</td><td>Calculate bounding box (members min_x, min_y, max_x, max_y, ratio of <a class="el" href="struct_my_region.html">MyRegion</a>) or not. Setting bCalculateBoundingBox to false saves computation time. </td></tr>
    <tr><td class="paramname">bStorePixels</td><td>Store pixels belonging to the region in the member <a class="el" href="struct_my_region.html#a23d649b05d07bf26eed5b94f6a2bb2be">MyRegion::pPixels</a>. Memory is handled automatically (allocation/deletion). Setting bStorePixels to false saves computation time. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l04269">4269</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9acfcdc1b4d7e15c29d35e4e8264f196"></a><!-- doxytag: member="ImageProcessor::FlipY" ref="a9acfcdc1b4d7e15c29d35e4e8264f196" args="(const CByteImage *pInputImage, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::FlipY </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flips the rows in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> vertically and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>Flips the rows in pInputImage vertically, i.e. mirros the image with the center axis, and writes the result to pOutputImage.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be either both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a> or both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l05722">5722</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af5729feba6dfd076a3ceafe8a1dbb7b5"></a><!-- doxytag: member="ImageProcessor::GaussianSmooth" ref="af5729feba6dfd076a3ceafe8a1dbb7b5" args="(const CByteImage *pInputImage, CFloatMatrix *pOutputImage, float fVariance, int nKernelSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::GaussianSmooth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fVariance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nKernelSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies a Gaussian filter to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a>. </p>
<p>Applies a Gaussian filter of size nKernelSize x nKernelSize to pInputImage and writes the result to pOutputImage.</p>
<p>The width and height of pInputImage must match the row and column count of pOutputImage.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">fVariance</td><td>The variance <img class="formulaInl" alt="$ \sigma^2 $" src="form_25.png"/> used for constructing the Gaussian kernel. </td></tr>
    <tr><td class="paramname">nKernelSize</td><td>Determines the side the length of the Gaussian kernel used for smoothing. It should meet the following criterion: <img class="formulaInl" alt="$ {\rm nKernelSize} \geq \lfloor 2\sigma \rfloor \cdot 2 + 1 $" src="form_26.png"/> to achieve a meaningful approximation. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l05379">5379</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aad5512260c8fb87ba4f5da68ed9d6214"></a><!-- doxytag: member="ImageProcessor::GaussianSmooth" ref="aad5512260c8fb87ba4f5da68ed9d6214" args="(const CFloatMatrix *pInputImage, CFloatMatrix *pOutputImage, float fVariance, int nKernelSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::GaussianSmooth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fVariance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nKernelSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies a Gaussian filter to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a> and writes the result to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a>. </p>
<p>Applies a Gaussian filter of size nKernelSize x nKernelSize to pInputImage and writes the result to pOutputImage.</p>
<p>The row and column count of pInputImage and pOutputImage must match.<br/>
 pInputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<p>If pInputImage and pOutputImage share the same memory area, the input image is copied to a temporary image first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">fVariance</td><td>The variance <img class="formulaInl" alt="$ \sigma^2 $" src="form_25.png"/> used for constructing the Gaussian kernel. </td></tr>
    <tr><td class="paramname">nKernelSize</td><td>Determines the size of the Gaussian kernel used for smoothing. It should meet the following criterion: <img class="formulaInl" alt="$ {\rm nKernelSize} \geq \lfloor 2\sigma \rfloor \cdot 2 + 1 $" src="form_26.png"/> to achieve a meaningful approximation. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l05510">5510</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6813a8de3a33d1da6ae8858b41d43ea8"></a><!-- doxytag: member="ImageProcessor::GaussianSmooth" ref="a6813a8de3a33d1da6ae8858b41d43ea8" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, float fVariance, int nKernelSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::GaussianSmooth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fVariance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nKernelSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies a Gaussian filter to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>Applies a Gaussian filter of size nKernelSize x nKernelSize to pInputImage and writes the result to pOutputImage.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<p>If pInputImage and pOutputImage share the same memory area, the input image is copied to a temporary image first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">fVariance</td><td>The variance <img class="formulaInl" alt="$ \sigma^2 $" src="form_25.png"/> used for constructing the Gaussian kernel. </td></tr>
    <tr><td class="paramname">nKernelSize</td><td>Determines the size of the Gaussian kernel used for smoothing. It should meet the following criterion: <img class="formulaInl" alt="$ {\rm nKernelSize} \geq \lfloor 2\sigma \rfloor \cdot 2 + 1 $" src="form_26.png"/> to achieve a meaningful approximation. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l05248">5248</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af749560ff627f4e4d610af30b2271212"></a><!-- doxytag: member="ImageProcessor::GaussianSmooth3x3" ref="af749560ff627f4e4d610af30b2271212" args="(const CByteImage *pInputImage, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::GaussianSmooth3x3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies a 3x3 Gaussian filter to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>Applies a 3x3 Gaussian low pass filter with <img class="formulaInl" alt="$ \sigma \approx 0.85 $" src="form_29.png"/>, i.e. variance = <img class="formulaInl" alt="$ \sigma^2 \approx 0.85^2 $" src="form_30.png"/>, to pInputImage and writes the result to pOutputImage. The used filter kernel is: <img class="formulaInl" alt="$ \frac{1}{16}\left(\begin{array}{ccc} 1 &amp; 2 &amp; 1\\ 2 &amp; 4 &amp; 2\\ 1 &amp; 2 &amp; 1\\ \end{array}\right) $" src="form_31.png"/>.</p>
<p>All calculations are performed with integer arithmetics.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be either both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a> or both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>.</p>
<p>If pInputImage and pOutputImage share the same memory area, the input image is copied to a temporary image first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l00688">688</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7beeb95db014939596671aee82c4446a"></a><!-- doxytag: member="ImageProcessor::GaussianSmooth5x5" ref="a7beeb95db014939596671aee82c4446a" args="(const CFloatMatrix *pInputImage, CFloatMatrix *pOutputImage, float fVariance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::GaussianSmooth5x5 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fVariance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies a 5x5 Gaussian filter to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a> and writes the result to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a>. </p>
<p>This is an optimized implementation of <a class="el" href="namespace_image_processor.html#aad5512260c8fb87ba4f5da68ed9d6214" title="Applies a Gaussian filter to a CFloatMatrix and writes the result to a CFloatMatrix.">GaussianSmooth(const CFloatMatrix *pInputImage, CFloatMatrix *pOutputImage, float fVariance, int nKernelSize)</a> for the special case of a 5x5 kernel, i.e. nKernelSize = 5.<br/>
 The row and column count of pInputImage and pOutputImage must match.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">fVariance</td><td>The variance <img class="formulaInl" alt="$ \sigma^2 $" src="form_25.png"/> used for constructing the Gaussian kernel. According to the formula <img class="formulaInl" alt="$ n \geq \lfloor 2\sigma \rfloor \cdot 2 + 1 $" src="form_27.png"/> (where n denotes the side length of the filter kernel, i.e. n = 5 for this function), it must be <img class="formulaInl" alt="$ \sigma^2 < 1.5^2 $" src="form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l05117">5117</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae58234b3f065a061844c8f7139f57be3"></a><!-- doxytag: member="ImageProcessor::GaussianSmooth5x5" ref="ae58234b3f065a061844c8f7139f57be3" args="(const CByteImage *pInputImage, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::GaussianSmooth5x5 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies a 5x5 Gaussian filter to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>Applies a 5x5 Gaussian filter with <img class="formulaInl" alt="$ \sigma \approx 0.9 $" src="form_32.png"/>, i.e. variance = <img class="formulaInl" alt="$ \sigma^2 \approx 0.9^2 $" src="form_33.png"/>, to pInputImage and writes the result to pOutputImage. The used filter kernel is: <img class="formulaInl" alt="$ \frac{1}{256}\left(\begin{array}{ccccc} 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1\\ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4\\ 6 &amp; 24 &amp; 36 &amp; 24 &amp; 6\\ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4\\ 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1 \end{array}\right) $" src="form_34.png"/>.</p>
<p>All calculations are performed with integer arithmetics.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<p>If pInputImage and pOutputImage share the same memory area, the input image is copied to a temporary image first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l00527">527</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="accfd2be6c64de76484453a654907394b"></a><!-- doxytag: member="ImageProcessor::GeneralFilter" ref="accfd2be6c64de76484453a654907394b" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, const int *pKernel, int nMaskSize, int nDivider=1, bool bAbsoluteValue=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::GeneralFilter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>pKernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaskSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDivider</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAbsoluteValue</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies a user defined filter to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>Applies a user defined filter of size nMaskSize x nMaskSize to pInputImage and writes the result to pOutputImage. Overflows are not handled. Use the functions <a class="el" href="namespace_image_processor.html#a556ce4364d37a80b44a11017c2bb00dd" title="Applies a user defined filter to a CByteImage and writes the result to a CShortImage.">GeneralFilter(const CByteImage*, CShortImage*, const int*, int, int, bool)</a> or <a class="el" href="namespace_image_processor.html#a8aea7219ff20434c3638734dc35f4f99" title="Applies a user defined filter to a CByteImage and writes the result to a CFloatMatrix.">GeneralFilter(const CByteImage*, CFloatMatrix*, const int*, int, int, bool)</a>, if overflows can potentially occur for the desired kernel or for higher precision.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<p>If pInputImage and pOutputImage share the same memory area, the input image is copied to a temporary image first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">pKernel</td><td>The filter kernel. The coefficients are expected to be stored row wise, starting from the top left corner. </td></tr>
    <tr><td class="paramname">nMaskSize</td><td>The side length of the filter kernel. Must be an odd integer greater than 2. </td></tr>
    <tr><td class="paramname">nDivider</td><td>Each value is divided by nDivider before it is written to pOutputImage. If nDivider = 1, then the division is omitted, thus saving computation time. </td></tr>
    <tr><td class="paramname">bAbsoluteValue</td><td>If true, the absolute values are written to pOutputImage. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l00163">163</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a556ce4364d37a80b44a11017c2bb00dd"></a><!-- doxytag: member="ImageProcessor::GeneralFilter" ref="a556ce4364d37a80b44a11017c2bb00dd" args="(const CByteImage *pInputImage, CShortImage *pOutputImage, const int *pKernel, int nMaskSize, int nDivider=1, bool bAbsoluteValue=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::GeneralFilter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_short_image.html">CShortImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>pKernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaskSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDivider</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAbsoluteValue</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies a user defined filter to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>. </p>
<p>Applies a user defined filter of size nMaskSize x nMaskSize to pInputImage and writes the result to pOutputImage. Overflows are not handled. Use the function <a class="el" href="namespace_image_processor.html#a8aea7219ff20434c3638734dc35f4f99" title="Applies a user defined filter to a CByteImage and writes the result to a CFloatMatrix.">GeneralFilter(const CByteImage*, CFloatMatrix*, const int*, int, int, bool)</a> for higher precision.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">pKernel</td><td>The filter kernel. The coefficients are expected to be stored row wise, starting from the top left corner. </td></tr>
    <tr><td class="paramname">nMaskSize</td><td>The side length of the filter kernel. Must be an odd integer greater than 2. </td></tr>
    <tr><td class="paramname">nDivider</td><td>Each value is divided by nDivider before it is written to pOutputImage. If nDivider = 1, then the division is omitted, thus saving computation time. </td></tr>
    <tr><td class="paramname">bAbsoluteValue</td><td>If true, the absolute values are written to pOutputImage. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l00281">281</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8aea7219ff20434c3638734dc35f4f99"></a><!-- doxytag: member="ImageProcessor::GeneralFilter" ref="a8aea7219ff20434c3638734dc35f4f99" args="(const CByteImage *pInputImage, CFloatMatrix *pOutputImage, const int *pKernel, int nMaskSize, int nDivider=1, bool bAbsoluteValue=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::GeneralFilter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>pKernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaskSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDivider</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAbsoluteValue</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies a user defined filter to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a>. </p>
<p>Applies a user defined filter of size nMaskSize x nMaskSize to pInputImage and writes the result to pOutputImage.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">pKernel</td><td>The filter kernel. The coefficients are expected to be stored row wise, starting from the top left corner. </td></tr>
    <tr><td class="paramname">nMaskSize</td><td>The side length of the filter kernel. Must be an odd integer greater than 2. </td></tr>
    <tr><td class="paramname">nDivider</td><td>Each value is divided by nDivider before it is written to pOutputImage. If nDivider = 1, then the division is omitted, thus saving computation time. </td></tr>
    <tr><td class="paramname">bAbsoluteValue</td><td>If true, the absolute values are written to pOutputImage. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l00388">388</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a15686fdb45f946c36b40563238e62bcc"></a><!-- doxytag: member="ImageProcessor::GetAreaSum" ref="a15686fdb45f946c36b40563238e62bcc" args="(const CIntImage *pIntegralImage, int min_x, int min_y, int max_x, int max_y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ImageProcessor::GetAreaSum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_int_image.html">CIntImage</a> *&#160;</td>
          <td class="paramname"><em>pIntegralImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Efficiently computes the sum of all pixel values in a rectangular area using integral image lookups. </p>
<p>This function efficiently computes <img class="formulaInl" alt="$ \sum_{i=min_x}^{max_x}\sum_{j=min_y}^{max_y} I_{i, j} $" src="form_64.png"/> using four memory lookups, where <img class="formulaInl" alt="$I$" src="form_65.png"/> denotes the original image the integral image was computed for. The integral image for a given grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> can be computed by calling the function <a class="el" href="namespace_image_processor.html#a5d72ae8d99e1fa4ca9875d7b12df1983" title="Calculates the integral image of a grayscale CByteImage and writes the result to a CIntImage...">CalculateIntegralImage(const CByteImage*, CIntImage*)</a>.</p>
<p>This function performs checking of bounds. For maximum speed, GetAreaSumNoChecks(const pIntegralImage*, int, int, int, int) is recommended, which, however, does not perform any bounds checking and requires min_x &gt;= 1 and min_y &gt;= 1.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pIntegralImage</td><td>The integral image. </td></tr>
    <tr><td class="paramname">min_x</td><td>The x-coordinate of the upper left corner of the rectangular region. Must be &gt;= 0. </td></tr>
    <tr><td class="paramname">min_y</td><td>The y-coordinate of the upper left corner of the rectangular region. Must be &gt;= 0. </td></tr>
    <tr><td class="paramname">max_x</td><td>The x-coordinate of the lower right corner of the rectangular region. Must be &lt; pInputImage-&gt;width. </td></tr>
    <tr><td class="paramname">max_y</td><td>The y-coordinate of the lower right corner of the rectangular region. Must be &lt; pInputImage-&gt;height. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l05951">5951</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b01ed69c6911bb334d1ec6a93d18abf"></a><!-- doxytag: member="ImageProcessor::GetAreaSum" ref="a6b01ed69c6911bb334d1ec6a93d18abf" args="(const CIntImage *pIntegralImage, const MyRegion *pRegion)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ImageProcessor::GetAreaSum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_int_image.html">CIntImage</a> *&#160;</td>
          <td class="paramname"><em>pIntegralImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_my_region.html">MyRegion</a> *&#160;</td>
          <td class="paramname"><em>pRegion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Efficiently computes the sum of all pixel values in a rectangular area using integral image lookups. </p>
<p>This is a convenience function, calling <a class="el" href="namespace_image_processor.html#a15686fdb45f946c36b40563238e62bcc" title="Efficiently computes the sum of all pixel values in a rectangular area using integral image lookups...">GetAreaSum(const CIntImage*, int, int, int, int)</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pIntegralImage</td><td>The integral image. </td></tr>
    <tr><td class="paramname">pRegion</td><td>The region entry that specifies the region of interest. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l05988">5988</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab34f1597ab090bb90229cf7b968fb19d"></a><!-- doxytag: member="ImageProcessor::GetAreaSumNoChecks" ref="ab34f1597ab090bb90229cf7b968fb19d" args="(const CIntImage *pIntegralImage, int min_x, int min_y, int max_x, int max_y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ImageProcessor::GetAreaSumNoChecks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_int_image.html">CIntImage</a> *&#160;</td>
          <td class="paramname"><em>pIntegralImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Efficiently computes the sum of all pixel values in a rectangular area using integral image lookups. </p>
<p>This function computes <img class="formulaInl" alt="$ \sum_{i=min_x}^{max_x}\sum_{j=min_y}^{max_y} I_{i, j} $" src="form_64.png"/> using an precomputed integral image.</p>
<p>This functions does not perform any bounds checks and requires min_x &gt;= 1 and min_y &gt;= 1. If min_x = 0 and min_y = 0 are relevant or bounds checking is required, the function GetAreaSum(const pIntegralImage*, int, int, int, int) should be used, which is, however, slightly slower.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pIntegralImage</td><td>The integral image. </td></tr>
    <tr><td class="paramname">min_x</td><td>The x-coordinate of the upper left corner of the rectangular region. Must be &gt;= 1. </td></tr>
    <tr><td class="paramname">min_y</td><td>The y-coordinate of the upper left corner of the rectangular region. Must be &gt;= 1. </td></tr>
    <tr><td class="paramname">max_x</td><td>The x-coordinate of the lower right corner of the rectangular region. Must be &lt; pInputImage-&gt;width. </td></tr>
    <tr><td class="paramname">max_y</td><td>The y-coordinate of the lower right corner of the rectangular region. Must be &lt; pInputImage-&gt;height. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l05976">5976</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80aba5fb12df62fb1e2c57771a5a5d96"></a><!-- doxytag: member="ImageProcessor::HighPassX3" ref="a80aba5fb12df62fb1e2c57771a5a5d96" args="(const CFloatMatrix *pInputImage, CFloatMatrix *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::HighPassX3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies a 1x3 highpass filter to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a> and write the result to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a>. </p>
<p>This is a simple highpass filter computing gradients in x-direction and is thus suitable for the detection of vertical edges. The used filter kernel is: <img class="formulaInl" alt="$ \left( \begin{array}{ccc} 1 &amp; 0 &amp; -1 \\ \end{array} \right) $" src="form_35.png"/>.</p>
<p>The row and column count of pInputImage and pOutputImage must match.</p>
<p>If pInputImage and pOutputImage share the same memory area, the input image is copied to a temporary image first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l05641">5641</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a47f052faf74d56cc5e50816e81837b8b"></a><!-- doxytag: member="ImageProcessor::HighPassY3" ref="a47f052faf74d56cc5e50816e81837b8b" args="(const CFloatMatrix *pInputImage, CFloatMatrix *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::HighPassY3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies a 3x1 highpass filter to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a> and writes the result to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a>. </p>
<p>This is a simple highpass filter computing gradients in y-direction and is thus suitable for the detection of horizontal edges. The used filter kernel is: <img class="formulaInl" alt="$ \left( \begin{array}{c} 1 \\ 0 \\ -1 \\ \end{array}\right) $" src="form_36.png"/>.</p>
<p>The row and column count of pInputImage and pOutputImage must match.</p>
<p>If pInputImage and pOutputImage share the same memory area, the input image is copied to a temporary image first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l05682">5682</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a670bf3a1bac61bf821f259172c0e9322"></a><!-- doxytag: member="ImageProcessor::HistogramEqualization" ref="a670bf3a1bac61bf821f259172c0e9322" args="(const CByteImage *pInputImage, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::HistogramEqualization </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs histogram equalization for a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>Performs histogram equalization by computing the accumulated histogram <img class="formulaInl" alt="$H_a$" src="form_44.png"/> for input image and using the following mapping function for writing pOutputImage: <img class="formulaInl" alt="$I_{out}(x, y) = \frac{255}{n} \cdot H_a(I_{in}(x, y))$" src="form_45.png"/>, where n denotes the number of pixels contained in pInputImage (resp. pOutputImage).</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 Both images must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<p>As this is a point operation, there is no copy overhead if pInputImage and pOutputImage share the same memory area.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l01842">1842</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a51855d6ca4445b64cbe4bcb8cb2383cf"></a><!-- doxytag: member="ImageProcessor::HistogramStretching" ref="a51855d6ca4445b64cbe4bcb8cb2383cf" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, float p1=0.1f, float p2=0.9f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::HistogramStretching </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>p1</em> = <code>0.1f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>p2</em> = <code>0.9f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs histogram stretching on pInputImage and stores the result in pOutputImage. </p>
<p>Linearly maps the interval [min, max] to [0, 255], where min/max are the two peaks of the histogram determined with the aid of a quantile analysis, assuming a bimodal histogram.<br/>
 If pInputImage is homogeneous, the values of pOutputImage are all set to zero.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 Both images must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<p>As this is a point operation, there is no copy overhead if pInputImage and pOutputImage share the same memory area.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">p1</td><td>The quantile used for determining the position of the first peak in the histogram (minimum intensity). </td></tr>
    <tr><td class="paramname">p2</td><td>The quantile used for determining the position of the second peak in the histogram (maximum intensity). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l01936">1936</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8d1fb3e8111d23de8077eb17555a4e33"></a><!-- doxytag: member="ImageProcessor::HoughTransformCircles" ref="a8d1fb3e8111d23de8077eb17555a4e33" args="(const CByteImage *pImage, CByteImage *pVisualizationImage, Vec3dList &amp;resultCircles, int rmin, int rmax, int nCirclesToExtract, int nMinHits=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::HoughTransformCircles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pVisualizationImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_math3d_8h.html#aa55e7c3f7c23ce7ca441ce8235bf265e">Vec3dList</a> &amp;&#160;</td>
          <td class="paramname"><em>resultCircles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nCirclesToExtract</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMinHits</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the Hough transform for circles on a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>This function implements the standard form of the Hough transform, which does not incorporate the edge directions in the voting algorithm. For more efficient and more precise circle detection it is recommended to use the function <a class="el" href="namespace_image_processor.html#ae5e51f356ef046e105f1314848fced33" title="Performs the Hough transform for circles, given a list of edge points and directions.">HoughTransformCircles(const CVec2dArray&amp;, const CVec2dArray&amp;, int, int, int, int, int, int, CVec3dArray&amp;, CDynamicArrayTemplate&lt;int&gt;&amp;, CByteImage*)</a>.</p>
<p>As input a binary image is assumed in pImage, where background pixels are encoded with the value 0 and foreground pixels are encoded with non-zero values (usually 255). It is recommended to use the function <a class="el" href="namespace_image_processor.html#a2ae90a1ded17ef4234ea928aa0992e95" title="Applies the Canny edge detector to a CByteImage and writes the result to a CByteImage.">Canny(const CByteImage*, CByteImage*, int, int)</a> to produce the input image for this function.</p>
<p>Circles are represented by the equations <img class="formulaInl" alt="$ u = u_m + r \cdot cos(\theta) $" src="form_56.png"/> and <img class="formulaInl" alt="$ v = v_m + r \cdot sin(\theta) $" src="form_57.png"/>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pImage</td><td>The input image. Must be a binary image of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>. </td></tr>
    <tr><td class="paramname">pVisualizationImage</td><td>If pVisualizationImage is not NULL, the recognized circles will be drawn in this image. </td></tr>
    <tr><td class="paramname">resultCircles</td><td>The list of recognized circles in pImage represented by tuples <img class="formulaInl" alt="$(u_m, v_m, r)$" src="form_58.png"/> ( <img class="formulaInl" alt="$u_m$" src="form_59.png"/> = <a class="el" href="struct_vec3d.html#ae2ae8cb19b29924660a496e7cdbbed01">Vec3d::x</a>, <img class="formulaInl" alt="$v_m$" src="form_60.png"/> = <a class="el" href="struct_vec3d.html#a7fb10cedcc973f0a7a5e047f42b14071">Vec3d::y</a>, <img class="formulaInl" alt="$r$" src="form_55.png"/> = <a class="el" href="struct_vec3d.html#ad930009e39fa372825be8d5fd37631fb">Vec3d::z</a>) according to the equations explained above. The function <a class="el" href="namespace_primitives_drawer.html#a2696c091e989a39601bff0614819572e" title="Draws a circle into a CByteImage.">PrimitivesDrawer::DrawCircle(CByteImage*, float, float, float, int, int, int, int, bool)</a> can be used for drawing circles specified by these parameters. </td></tr>
    <tr><td class="paramname">rmin</td><td>The minimum radius. The smaller this value, the greater is the computational effort. </td></tr>
    <tr><td class="paramname">rmax</td><td>The maximum radius. The greater this value, the greater is the computatoinal effort. </td></tr>
    <tr><td class="paramname">nCirclesToExtract</td><td>At most nCirclesToExtract circles are extracted. The greater this value, the greater is the computational effort. </td></tr>
    <tr><td class="paramname">nMinHits</td><td>The minimum number of votes a circle needs to receive before being recognized as a circle. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l04660">4660</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae5e51f356ef046e105f1314848fced33"></a><!-- doxytag: member="ImageProcessor::HoughTransformCircles" ref="ae5e51f356ef046e105f1314848fced33" args="(const CVec2dArray &amp;edgePoints, const CVec2dArray &amp;edgeDirections, int width, int height, int rmin, int rmax, int nCirclesToExtract, int nMinHits, CVec3dArray &amp;resultCircles, CDynamicArrayTemplate&lt; int &gt; &amp;resultHits, CByteImage *pVisualizationImage=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::HoughTransformCircles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_dynamic_array_template.html">CVec2dArray</a> &amp;&#160;</td>
          <td class="paramname"><em>edgePoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_dynamic_array_template.html">CVec2dArray</a> &amp;&#160;</td>
          <td class="paramname"><em>edgeDirections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nCirclesToExtract</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMinHits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_dynamic_array_template.html">CVec3dArray</a> &amp;&#160;</td>
          <td class="paramname"><em>resultCircles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_dynamic_array_template.html">CDynamicArrayTemplate</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultHits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pVisualizationImage</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the Hough transform for circles, given a list of edge points and directions. </p>
<p>This function implements an improved form of the Hough transform, which also incorporates the edge directions in the voting algorithm. The standard version of the Hough transform for straight lines is implemented in <a class="el" href="namespace_image_processor.html#a8d1fb3e8111d23de8077eb17555a4e33" title="Performs the Hough transform for circles on a CByteImage.">HoughTransformCircles(const CByteImage*, CByteImage*, Vec3dList&amp;, int, int, int, int)</a>.</p>
<p>As input lists with edge points and edge directions are required. It is recommended to use the function <a class="el" href="namespace_image_processor.html#afe545b2a840d0f81b86f06abd362bbe7" title="Applies the Canny edge detector to a CByteImage and writes the edge pixels and directions to two inst...">Canny(const CByteImage*, CVec2dArray&amp;, CVec2dArray&amp;, int, int)</a> to produce these input lists for this function.</p>
<p>Circles are represented by the equations <img class="formulaInl" alt="$ u = u_m + r \cdot cos(\theta) $" src="form_56.png"/> and <img class="formulaInl" alt="$ v = v_m + r \cdot sin(\theta) $" src="form_57.png"/>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">edgePoints</td><td>The list containing the edge points. </td></tr>
    <tr><td class="paramname">edgeDirections</td><td>The list containing the edge directions. Must be of same size as the parameter edgePoints and entries with same index must correspond. </td></tr>
    <tr><td class="paramname">width</td><td>The width of the image the edge points/directions were computed for. </td></tr>
    <tr><td class="paramname">height</td><td>The height of the image the edge points/directions were computed for. </td></tr>
    <tr><td class="paramname">rmin</td><td>The minimum radius. The smaller this value, the greater is the computational effort. </td></tr>
    <tr><td class="paramname">rmax</td><td>The maximum radius. The greater this value, the greater is the computatoinal effort. </td></tr>
    <tr><td class="paramname">nCirclesToExtract</td><td>At most nCirclesToExtract circles are extracted. The greater this value, the greater is the computational effort. </td></tr>
    <tr><td class="paramname">nMinHits</td><td>The minimum number of votes a circle needs to receive before being recognized as a circle. </td></tr>
    <tr><td class="paramname">resultCircles</td><td>The list of recognized circles in pImage represented by tuples <img class="formulaInl" alt="$ (u_m, v_m, r) $" src="form_61.png"/> ( <img class="formulaInl" alt="$u_m$" src="form_59.png"/> = <a class="el" href="struct_vec3d.html#ae2ae8cb19b29924660a496e7cdbbed01">Vec3d::x</a>, <img class="formulaInl" alt="$v_m$" src="form_60.png"/> = <a class="el" href="struct_vec3d.html#a7fb10cedcc973f0a7a5e047f42b14071">Vec3d::y</a>, <img class="formulaInl" alt="$r$" src="form_55.png"/> = <a class="el" href="struct_vec3d.html#ad930009e39fa372825be8d5fd37631fb">Vec3d::z</a>) according to the equations explained above. The function <a class="el" href="namespace_primitives_drawer.html#a2696c091e989a39601bff0614819572e" title="Draws a circle into a CByteImage.">PrimitivesDrawer::DrawCircle(CByteImage*, float, float, float, int, int, int, int, bool)</a> can be used for drawing circles specified by these parameters. </td></tr>
    <tr><td class="paramname">resultHits</td><td>The list containing the number of hits for corresponding entries in resultCircles. </td></tr>
    <tr><td class="paramname">pVisualizationImage</td><td>If pVisualizationImage is not NULL, the recognized circles will be drawn in here. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l04879">4879</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a56ad405c66668fcf3358ce1deb35caa5"></a><!-- doxytag: member="ImageProcessor::HoughTransformLines" ref="a56ad405c66668fcf3358ce1deb35caa5" args="(const CVec2dArray &amp;edgePoints, const CVec2dArray &amp;edgeDirections, int width, int height, int nLinesToExtract, int nMinHits, CVec2dArray &amp;resultLines, CDynamicArrayTemplate&lt; int &gt; &amp;resultHits, CByteImage *pVisualizationImage=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::HoughTransformLines </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_dynamic_array_template.html">CVec2dArray</a> &amp;&#160;</td>
          <td class="paramname"><em>edgePoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_dynamic_array_template.html">CVec2dArray</a> &amp;&#160;</td>
          <td class="paramname"><em>edgeDirections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLinesToExtract</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMinHits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_dynamic_array_template.html">CVec2dArray</a> &amp;&#160;</td>
          <td class="paramname"><em>resultLines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_dynamic_array_template.html">CDynamicArrayTemplate</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultHits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pVisualizationImage</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the Hough transform for straight lines, given a list of edge points and directions. </p>
<p>This function implements an improved form of the Hough transform, which also incorporates the edge directions in the voting algorithm. The standard version of the Hough transform for straight lines is implemented in <a class="el" href="namespace_image_processor.html#aef8c2053fd031ba88c291a7ff667757e" title="Performs the Hough transform for straight lines on a CByteImage.">HoughTransformLines(const CByteImage*, CByteImage*, Vec2dList&amp;, int, int)</a>.</p>
<p>As input lists with edge points and edge directions are required. It is recommended to use the function <a class="el" href="namespace_image_processor.html#afe545b2a840d0f81b86f06abd362bbe7" title="Applies the Canny edge detector to a CByteImage and writes the edge pixels and directions to two inst...">Canny(const CByteImage*, CVec2dArray&amp;, CVec2dArray&amp;, int, int)</a> to produce these input lists for this function.</p>
<p>Lines are represented with the aid of polar coordinates: <img class="formulaInl" alt="$ r = u \cdot cos(\theta) + v \cdot sin(\theta) $" src="form_52.png"/>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">edgePoints</td><td>The list containing the edge points. </td></tr>
    <tr><td class="paramname">edgeDirections</td><td>The list containing the edge directions. Must be of same size as the parameter edgePoints and entries with same index must correspond. </td></tr>
    <tr><td class="paramname">width</td><td>The width of the image the edge points/directions were computed for. </td></tr>
    <tr><td class="paramname">height</td><td>The height of the image the edge points/directions were computed for. </td></tr>
    <tr><td class="paramname">nLinesToExtract</td><td>At most nLinesToExtract lines are extracted. The greater this value, the greater is the computational effort. </td></tr>
    <tr><td class="paramname">nMinHits</td><td>The minimum number of votes a line needs to receive before being recognized as a line. </td></tr>
    <tr><td class="paramname">resultLines</td><td>The list of recognized lines represented by tuples <img class="formulaInl" alt="$ (\theta, r) $" src="form_54.png"/> ( <img class="formulaInl" alt="$\theta$" src="form_53.png"/> = <a class="el" href="struct_vec2d.html#ad310afcd252c8f57d3aa5d1ffaa31246">Vec2d::x</a>, <img class="formulaInl" alt="$r$" src="form_55.png"/> = <a class="el" href="struct_vec2d.html#a49d1b0932179db2d3810cf88a5af598a">Vec2d::y</a>) according to the polar coordinate form explained above. The function <a class="el" href="namespace_primitives_drawer.html#a0db1055aab45bb6d9926c2d24ae0d24b" title="Draws a straight line into a CByteImage, given its parameters in polar form.">PrimitivesDrawer::DrawLinePolar(CByteImage*, float, float, int, int, int)</a> can be used for drawing lines specified by these parameters. </td></tr>
    <tr><td class="paramname">resultHits</td><td>The list containing the number of hits for corresponding entries in resultLines. </td></tr>
    <tr><td class="paramname">pVisualizationImage</td><td>If pVisualizationImage is not NULL, the recognized lines will be drawn in here. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l04778">4778</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef8c2053fd031ba88c291a7ff667757e"></a><!-- doxytag: member="ImageProcessor::HoughTransformLines" ref="aef8c2053fd031ba88c291a7ff667757e" args="(const CByteImage *pImage, CByteImage *pVisualizationImage, Vec2dList &amp;resultLines, int nLinesToExtract, int nMinHits=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::HoughTransformLines </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pVisualizationImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_math2d_8h.html#a4739bac2860beeadc217ef0f27eec8d4">Vec2dList</a> &amp;&#160;</td>
          <td class="paramname"><em>resultLines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLinesToExtract</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMinHits</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the Hough transform for straight lines on a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>This function implements the standard form of the Hough transform, which does not incorporate the edge directions in the voting algorithm. For more efficient and more precise line detection it is recommended to use the function <a class="el" href="namespace_image_processor.html#a56ad405c66668fcf3358ce1deb35caa5" title="Performs the Hough transform for straight lines, given a list of edge points and directions.">HoughTransformLines(const CVec2dArray&amp;, const CVec2dArray&amp;, int, int, int, int, CVec2dArray&amp;, CDynamicArrayTemplate&lt;int&gt;&amp;, CByteImage*)</a>.</p>
<p>As input a binary image is assumed in pImage, where background pixels are encoded with the value 0 and foreground pixels are encoded with non-zero values (usually 255). It is recommended to use the function <a class="el" href="namespace_image_processor.html#a2ae90a1ded17ef4234ea928aa0992e95" title="Applies the Canny edge detector to a CByteImage and writes the result to a CByteImage.">Canny(const CByteImage*, CByteImage*, int, int)</a> to produce the input image for this function.</p>
<p>Lines are represented with by polar coordinates: <img class="formulaInl" alt="$ r = u \cdot cos(\theta) + v \cdot sin(\theta) $" src="form_52.png"/>, where (u, v) denote image coordinates, <img class="formulaInl" alt="$\theta$" src="form_53.png"/> is the angle of the normal vector and r is the distance of the line to the origin.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pImage</td><td>The input image. Must be a binary image of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>. </td></tr>
    <tr><td class="paramname">pVisualizationImage</td><td>If pVisualizationImage is not NULL, the recognized lines will be drawn in this image. </td></tr>
    <tr><td class="paramname">resultLines</td><td>The list of recognized lines represented by tuples <img class="formulaInl" alt="$ (\theta, r) $" src="form_54.png"/> ( <img class="formulaInl" alt="$\theta$" src="form_53.png"/> = <a class="el" href="struct_vec2d.html#ad310afcd252c8f57d3aa5d1ffaa31246">Vec2d::x</a>, <img class="formulaInl" alt="$r$" src="form_55.png"/> = <a class="el" href="struct_vec2d.html#a49d1b0932179db2d3810cf88a5af598a">Vec2d::y</a>) according to the polar coordinate form explained above. The function <a class="el" href="namespace_primitives_drawer.html#a0db1055aab45bb6d9926c2d24ae0d24b" title="Draws a straight line into a CByteImage, given its parameters in polar form.">PrimitivesDrawer::DrawLinePolar(CByteImage*, float, float, int, int, int)</a> can be used for drawing lines specified by these parameters. </td></tr>
    <tr><td class="paramname">nLinesToExtract</td><td>At most nLinesToExtract lines are extracted. The greater this value, the greater is the computational effort. </td></tr>
    <tr><td class="paramname">nMinHits</td><td>The minimum number of votes a line needs to receive before being recognized as a line. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l04562">4562</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6c196fc78d0f79ef77d58fdaf3da54c7"></a><!-- doxytag: member="ImageProcessor::Invert" ref="a6c196fc78d0f79ef77d58fdaf3da54c7" args="(const CByteImage *pInputImage, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the inverted image of a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>Inverting is accomplished by calculating 255 - value for each byte value.</p>
<p>The width, height and type of pInputImage and pOutputImage must match. All types of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> are supported (<a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea49137e7257d209b4b831bb271c2f69bf">CByteImage::eRGB24Split</a>).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l01992">1992</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb680fabbf995350755cdca3da9df3f8"></a><!-- doxytag: member="ImageProcessor::Laplace1" ref="adb680fabbf995350755cdca3da9df3f8" args="(const CByteImage *pInputImage, CShortImage *pOutputImage, bool bAbsoluteValue=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Laplace1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_short_image.html">CShortImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAbsoluteValue</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Filters a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with the Laplace1 operator and writes the result to a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>. </p>
<p>The Laplace1 operator is an omnidirectional high pass filter (edge filter). It is an approximation of a second order derivative. The used filter kernel is: <img class="formulaInl" alt="$ \left(\begin{array}{ccc} 0 &amp; 1 &amp; 0 \\ 1 &amp; -4 &amp; 1 \\ 0 &amp; 1 &amp; 0 \\ \end{array}\right) $" src="form_41.png"/>.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">bAbsoluteValue</td><td>If true, the absolute values are written to pOutputImage. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l01010">1010</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a24f814d2ce7acfc8ef63e73c83708c1f"></a><!-- doxytag: member="ImageProcessor::Laplace1" ref="a24f814d2ce7acfc8ef63e73c83708c1f" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, bool bAbsoluteValue=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Laplace1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAbsoluteValue</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Filters a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with the Laplace1 operator and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>This function is a convenience function, creating an instance of <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>, calling <a class="el" href="namespace_image_processor.html#adb680fabbf995350755cdca3da9df3f8" title="Filters a CByteImage with the Laplace1 operator and writes the result to a CShortImage.">Laplace1(const CByteImage*, CShortImage*, bool)</a>, and then calling <a class="el" href="namespace_image_processor.html#a53d89906c569cf675efbb413012efce0" title="Converts a CShortImage to a grayscale CByteImage.">ConvertImage(const CShortImage*, CByteImage*)</a>. See the documentations of these functions for further information. Note that there is no runtime penalty if pInputImage and pOutputImage share the same memory area, since a temporary instance of <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a> is used for storing the result of the convolution in any case.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">bAbsoluteValue</td><td>If true, the absolute values are written to pOutputImage. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l00996">996</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2f55c87dc6c94a8626937c900d200150"></a><!-- doxytag: member="ImageProcessor::Laplace2" ref="a2f55c87dc6c94a8626937c900d200150" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, bool bAbsoluteValue=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Laplace2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAbsoluteValue</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Filters a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with the Laplace2 operator and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>This function is a convenience function, creating an instance of <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>, calling <a class="el" href="namespace_image_processor.html#a28fcdca817d678cfd272b36b769e2b90" title="Filters a CByteImage with the Laplace2 operator and writes the result to a CShortImage.">Laplace2(const CByteImage*, CShortImage*, bool)</a>, and then calling <a class="el" href="namespace_image_processor.html#a53d89906c569cf675efbb413012efce0" title="Converts a CShortImage to a grayscale CByteImage.">ConvertImage(const CShortImage*, CByteImage*)</a>. See the documentations of these functions for further information. Note that there is no runtime penalty if pInputImage and pOutputImage share the same memory area, since a temporary instance of <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a> is used for storing the result of the convolution in any case.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">bAbsoluteValue</td><td>If true, the absolute values are written to pOutputImage. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l01003">1003</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a28fcdca817d678cfd272b36b769e2b90"></a><!-- doxytag: member="ImageProcessor::Laplace2" ref="a28fcdca817d678cfd272b36b769e2b90" args="(const CByteImage *pInputImage, CShortImage *pOutputImage, bool bAbsoluteValue=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Laplace2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_short_image.html">CShortImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAbsoluteValue</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Filters a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with the Laplace2 operator and writes the result to a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>. </p>
<p>The Laplace2 operator is an omnidirectional high pass filter (edge filter). It is an approximation of a second order derivative. The used filter kernel is: <img class="formulaInl" alt="$ \left(\begin{array}{ccc} 1 &amp; 1 &amp; 1 \\ 1 &amp; -8 &amp; 1 \\ 1 &amp; 1 &amp; 1 \\ \end{array}\right) $" src="form_42.png"/>.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">bAbsoluteValue</td><td>If true, the absolute values are written to pOutputImage. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l01058">1058</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1dbb2c1b690a05deba6de8907af45d1d"></a><!-- doxytag: member="ImageProcessor::Max" ref="a1dbb2c1b690a05deba6de8907af45d1d" args="(const CByteImage *pInputImage1, const CByteImage *pInputImage2, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets each pixel in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to the maximum of the corresponding pixels in two instances of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>This function implements the following point operation: pOutputImage-&gt;pixels[i] = MY_MAX(pInputImage1-&gt;pixels[i], pInputImage2-&gt;pixels[i]).</p>
<p>The width, height and type of pInputImage1, pInputImage2 and pOutputImage must match.<br/>
 All types of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> are supported (<a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea49137e7257d209b4b831bb271c2f69bf">CByteImage::eRGB24Split</a>).</p>
<p>As this is a point operation, there is no copy overhead if pInputImage1, pInputImage2, or pOutputImage share the same memory area.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage1</td><td>The first input image. </td></tr>
    <tr><td class="paramname">pInputImage2</td><td>The second input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l06787">6787</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af2a46b97b2adc374e5f1f7d8c7e7eb48"></a><!-- doxytag: member="ImageProcessor::MaxValue" ref="af2a46b97b2adc374e5f1f7d8c7e7eb48" args="(const CIntImage *pImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ImageProcessor::MaxValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_int_image.html">CIntImage</a> *&#160;</td>
          <td class="paramname"><em>pImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the maximum value within a <a class="el" href="class_c_int_image.html" title="Data structure for the representation of single channel images of the data type signed int...">CIntImage</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pImage</td><td>The input image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l06858">6858</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7a1eed4f8955b6d4cda5cdbea0befaf4"></a><!-- doxytag: member="ImageProcessor::MaxValue" ref="a7a1eed4f8955b6d4cda5cdbea0befaf4" args="(const CByteImage *pImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char ImageProcessor::MaxValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the maximum value within a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pImage</td><td>The input image. Must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l06810">6810</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aac08c7c9378866247e45c1f0f3512247"></a><!-- doxytag: member="ImageProcessor::MaxValue" ref="aac08c7c9378866247e45c1f0f3512247" args="(const CShortImage *pImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short ImageProcessor::MaxValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_short_image.html">CShortImage</a> *&#160;</td>
          <td class="paramname"><em>pImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the maximum value within a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pImage</td><td>The input image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l06837">6837</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a171d1f1c287ac0049ad8fb7fe838d57c"></a><!-- doxytag: member="ImageProcessor::Min" ref="a171d1f1c287ac0049ad8fb7fe838d57c" args="(const CByteImage *pInputImage1, const CByteImage *pInputImage2, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets each pixel in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to the minimum of the corresponding pixels in two instances of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>This function implements the following point operation: pOutputImage-&gt;pixels[i] = MY_MIN(pInputImage1-&gt;pixels[i], pInputImage2-&gt;pixels[i]).</p>
<p>The width, height and type of pInputImage1, pInputImage2 and pOutputImage must match.<br/>
 All types of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> are supported (<a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea49137e7257d209b4b831bb271c2f69bf">CByteImage::eRGB24Split</a>).</p>
<p>As this is a point operation, there is no copy overhead if pInputImage1, pInputImage2, or pOutputImage share the same memory area.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage1</td><td>The first input image. </td></tr>
    <tr><td class="paramname">pInputImage2</td><td>The second input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l06765">6765</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a15f7dbc458e33312d4a366e332bf8a02"></a><!-- doxytag: member="ImageProcessor::MinMaxValue" ref="a15f7dbc458e33312d4a366e332bf8a02" args="(const CShortImage *pImage, short &amp;min, short &amp;max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::MinMaxValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_short_image.html">CShortImage</a> *&#160;</td>
          <td class="paramname"><em>pImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the minimum and maximum value within a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">min</td><td>The result parameter containing the minimum value after execution. </td></tr>
    <tr><td class="paramname">max</td><td>The result parameter containing the maximum value after execution. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l06975">6975</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad297816b76624337cf4b2e3166c0e4a1"></a><!-- doxytag: member="ImageProcessor::MinMaxValue" ref="ad297816b76624337cf4b2e3166c0e4a1" args="(const CIntImage *pImage, int &amp;min, int &amp;max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::MinMaxValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_int_image.html">CIntImage</a> *&#160;</td>
          <td class="paramname"><em>pImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the minimum and maximum value within a <a class="el" href="class_c_int_image.html" title="Data structure for the representation of single channel images of the data type signed int...">CIntImage</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">min</td><td>The result parameter containing the minimum value after execution. </td></tr>
    <tr><td class="paramname">max</td><td>The result parameter containing the maximum value after execution. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l06996">6996</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ada0d308b227919eeef8ef9bc03e1edd1"></a><!-- doxytag: member="ImageProcessor::MinMaxValue" ref="ada0d308b227919eeef8ef9bc03e1edd1" args="(const CByteImage *pImage, unsigned char &amp;min, unsigned char &amp;max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::MinMaxValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the minimum and maximum value within a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pImage</td><td>The input image. Must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>. </td></tr>
    <tr><td class="paramname">min</td><td>The result parameter containing the minimum value after execution. </td></tr>
    <tr><td class="paramname">max</td><td>The result parameter containing the maximum value after execution. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l06948">6948</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a865e628d7b2638d79e159f9ac1560f65"></a><!-- doxytag: member="ImageProcessor::MinValue" ref="a865e628d7b2638d79e159f9ac1560f65" args="(const CShortImage *pImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short ImageProcessor::MinValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_short_image.html">CShortImage</a> *&#160;</td>
          <td class="paramname"><em>pImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the minimum value within a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pImage</td><td>The input image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l06906">6906</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d356d21ca08507266ecdc5621f953ad"></a><!-- doxytag: member="ImageProcessor::MinValue" ref="a2d356d21ca08507266ecdc5621f953ad" args="(const CByteImage *pImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char ImageProcessor::MinValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the minimum value within a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pImage</td><td>The input image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l06879">6879</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4a553911babe3b0b5fb3d1ac0fb09645"></a><!-- doxytag: member="ImageProcessor::MinValue" ref="a4a553911babe3b0b5fb3d1ac0fb09645" args="(const CIntImage *pImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ImageProcessor::MinValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_int_image.html">CIntImage</a> *&#160;</td>
          <td class="paramname"><em>pImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the minimum value within a <a class="el" href="class_c_int_image.html" title="Data structure for the representation of single channel images of the data type signed int...">CIntImage</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pImage</td><td>The input image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l06927">6927</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a77ac686c036567c1fa01682eff53b306"></a><!-- doxytag: member="ImageProcessor::NormalizeColor" ref="a77ac686c036567c1fa01682eff53b306" args="(const CByteImage *pInputImage, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::NormalizeColor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies histogram equalization to all channels of a color <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>Applies histogram equalization to all three channels of a color image independently.</p>
<p>The width, height and type of pInputImage and pOutputImage must match.<br/>
 All types of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> are supported (<a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea49137e7257d209b4b831bb271c2f69bf">CByteImage::eRGB24Split</a>).</p>
<p>As this is a point operation, there is no copy overhead if pInputImage and pOutputImage share the same memory area.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. Must be a color image of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a> or <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea49137e7257d209b4b831bb271c2f69bf">CByteImage::eRGB24Split</a>. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. Must be of the same type as pInputImage. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l05035">5035</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a472f39c42aecbc10e1a3b4e648519152"></a><!-- doxytag: member="ImageProcessor::Or" ref="a472f39c42aecbc10e1a3b4e648519152" args="(const CByteImage *pInputImage1, const CByteImage *pInputImage2, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Or </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the bitwise operator OR to two instance of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>This function implements the following point operation: pOutputImage-&gt;pixels[i] = pInputImage1-&gt;pixels[i] | pInputImage2-&gt;pixels[i].</p>
<p>The width, height and type of pInputImage1, pInputImage2 and pOutputImage must match.<br/>
 All types of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> are supported (<a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea49137e7257d209b4b831bb271c2f69bf">CByteImage::eRGB24Split</a>).</p>
<p>As this is a point operation, there is no copy overhead if pInputImage1, pInputImage2, or pOutputImage share the same memory area.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage1</td><td>The first input image. </td></tr>
    <tr><td class="paramname">pInputImage2</td><td>The second input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l06611">6611</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7f4c03d300f5e35655d00e28b154b914"></a><!-- doxytag: member="ImageProcessor::PixelSum" ref="a7f4c03d300f5e35655d00e28b154b914" args="(const CByteImage *pImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ImageProcessor::PixelSum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the sum of all pixel values of a grayscale <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pImage</td><td>The input image. Must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l07018">7018</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aecc27bc30495075798d8861e6fd7cf8c"></a><!-- doxytag: member="ImageProcessor::PrewittX" ref="aecc27bc30495075798d8861e6fd7cf8c" args="(const CByteImage *pInputImage, CShortImage *pOutputImage, bool bAbsoluteValue=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::PrewittX </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_short_image.html">CShortImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAbsoluteValue</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Filters a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with the PrewittX operator and writes the result to a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>. </p>
<p>The PrewittX operator computes gradients in x-direction and is thus suitable for the detection of vertical edges. The used filter kernel is: <img class="formulaInl" alt="$ \left(\begin{array}{ccc} -1 &amp; 0 &amp; 1\\ -1 &amp; 0 &amp; 1\\ -1 &amp; 0 &amp; 1\\ \end{array}\right) $" src="form_39.png"/>.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">bAbsoluteValue</td><td>If true, the absolute values are written to pOutputImage, i.e. edge direction information is lost. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l00947">947</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae846f23e4ee223c1fb06e52f674763d5"></a><!-- doxytag: member="ImageProcessor::PrewittX" ref="ae846f23e4ee223c1fb06e52f674763d5" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, bool bAbsoluteValue=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::PrewittX </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAbsoluteValue</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Filters a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with the PrewittX operator and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>This function is a convenience function, creating an instance of <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>, calling <a class="el" href="namespace_image_processor.html#aecc27bc30495075798d8861e6fd7cf8c" title="Filters a CByteImage with the PrewittX operator and writes the result to a CShortImage.">PrewittX(const CByteImage*, CShortImage*, bool)</a>, and then calling <a class="el" href="namespace_image_processor.html#a53d89906c569cf675efbb413012efce0" title="Converts a CShortImage to a grayscale CByteImage.">ConvertImage(const CShortImage*, CByteImage*)</a>. See the documentations of these functions for further information. Note that there is no runtime penalty if pInputImage and pOutputImage share the same memory area, since a temporary instance of <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a> is used for storing the result of the convolution in any case.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">bAbsoluteValue</td><td>If true, the absolute values are written to pOutputImage, i.e. edge direction information is lost. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l00887">887</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af9f5c50fdfd261f873e4f4ff0c0e03a0"></a><!-- doxytag: member="ImageProcessor::PrewittY" ref="af9f5c50fdfd261f873e4f4ff0c0e03a0" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, bool bAbsoluteValue=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::PrewittY </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAbsoluteValue</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Filters a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with the PrewittY operator and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>This function is a convenience function, creating an instance of <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>, calling <a class="el" href="namespace_image_processor.html#a9c099e921d75cf4cf0a2e0677c8c7e52" title="Filters a CByteImage with the PrewittY operator and writes the result to a CShortImage.">PrewittY(const CByteImage*, CShortImage*, bool)</a>, and then calling <a class="el" href="namespace_image_processor.html#a53d89906c569cf675efbb413012efce0" title="Converts a CShortImage to a grayscale CByteImage.">ConvertImage(const CShortImage*, CByteImage*)</a>. See the documentations of these functions for further information. Note that there is no runtime penalty if pInputImage and pOutputImage share the same memory area, since a temporary instance of <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a> is used for storing the result of the convolution in any case.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">bAbsoluteValue</td><td>If true, the absolute values are written to pOutputImage, i.e. edge direction information is lost. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l00894">894</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c099e921d75cf4cf0a2e0677c8c7e52"></a><!-- doxytag: member="ImageProcessor::PrewittY" ref="a9c099e921d75cf4cf0a2e0677c8c7e52" args="(const CByteImage *pInputImage, CShortImage *pOutputImage, bool bAbsoluteValue=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::PrewittY </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_short_image.html">CShortImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAbsoluteValue</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Filters a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with the PrewittY operator and writes the result to a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>. </p>
<p>The PrewittY operator computes gradients in y-direction and is thus suitable for the detection of horizontal edges. The used filter kernel is: <img class="formulaInl" alt="$ \left(\begin{array}{ccc} -1 &amp; -1 &amp; -1\\ 0 &amp; 0 &amp; 0\\ 1 &amp; 1 &amp; 1\\ \end{array}\right) $" src="form_40.png"/>.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">bAbsoluteValue</td><td>If true, the absolute values are written to pOutputImage, i.e. edge direction information is lost. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l00901">901</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab6d83877d812a227c3ec1552f18bc5ca"></a><!-- doxytag: member="ImageProcessor::RegionGrowing" ref="ab6d83877d812a227c3ec1552f18bc5ca" args="(const CByteImage *pInputImage, MyRegion &amp;resultRegion, int x, int y, int nMinimumPointsPerRegion=0, int nMaximumPointsPerRegion=0, bool bCalculateBoundingBox=true, bool bStorePixels=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ImageProcessor::RegionGrowing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_my_region.html">MyRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>resultRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMinimumPointsPerRegion</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaximumPointsPerRegion</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCalculateBoundingBox</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bStorePixels</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a region growing on a binary <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> on the basis of one seed point and stores the computed region in a <a class="el" href="struct_my_region.html">MyRegion</a>. </p>
<p>The region growing algorithm segments the set of connected foreground pixels (4-connectivity) around a given seed point.</p>
<p>The input image is assumed to encode background with the value 0 and foreground with the value 255.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. Must be a binary image of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>. </td></tr>
    <tr><td class="paramname">resultRegion</td><td>The region entry, in which the information about the region to be detected will be stored. </td></tr>
    <tr><td class="paramname">x</td><td>The x-coordinate of the seed point. Must lie within the bounds of pInputImage, i.e. &gt;= 0 and &lt; pInputImage-&gt;width. </td></tr>
    <tr><td class="paramname">y</td><td>The y-coordinate of the seed point. Must lie within the bounds of pInputImage, i.e. &gt;= 0 and &lt; pInputImage-&gt;height. </td></tr>
    <tr><td class="paramname">nMinimumPointsPerRegion</td><td>Specifies the minimum number of pixels the region must contain. If the region contains less pixels, the function returns 0. The default value nMinimumPointsPerRegion = 0 means that no lower bound is checked. </td></tr>
    <tr><td class="paramname">nMaximumPointsPerRegion</td><td>Specifies the maximum number of pixels the region may contain. If the region contains more pixels, the function returns 0. The default value nMaximumPointsPerRegion = 0 means that no upper bound is checked. </td></tr>
    <tr><td class="paramname">bCalculateBoundingBox</td><td>Calculate bounding box (members min_x, min_y, max_x, max_y, ratio of <a class="el" href="struct_my_region.html">MyRegion</a>) or not. Setting bCalculateBoundingBox to false saves computation time. </td></tr>
    <tr><td class="paramname">bStorePixels</td><td>Store pixels belonging to the region in the member <a class="el" href="struct_my_region.html#a23d649b05d07bf26eed5b94f6a2bb2be">MyRegion::pPixels</a>. Memory is handled automatically (allocation/deletion). Setting bStorePixels to false saves computation time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of pixels in resultRegion. If an error occurs, -1 is returned. If the segmented region does not fulfill the size constraints, 0 is returned. After a successful call, the return value is at least 1 (for the seed point). </dd></dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l04152">4152</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7f5c80c5cbdd1845c3e9fb6f2a8a24bb"></a><!-- doxytag: member="ImageProcessor::Resize" ref="a7f5c80c5cbdd1845c3e9fb6f2a8a24bb" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, const MyRegion *pROI=0, bool bInterpolation=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Resize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_my_region.html">MyRegion</a> *&#160;</td>
          <td class="paramname"><em>pROI</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bInterpolation</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resizes a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>The image stored in pInputImage is resized to the dimensions specified by pOutputImage. The result is written to pOutputImage.</p>
<p>pInputImage and pOutputImage must be either both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a> or both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">pROI</td><td>Describes the area within pInputImage containing the pixels which shall be resized. If pROI is 0, then the whole image contained in pInputImage is resized. </td></tr>
    <tr><td class="paramname">bInterpolation</td><td>Determines whether bilinear interpolation is used or not. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l03260">3260</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af18610f17a3f57e840639fb2bc1e1ff1"></a><!-- doxytag: member="ImageProcessor::Rotate" ref="af18610f17a3f57e840639fb2bc1e1ff1" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, float mx, float my, float theta, bool bInterpolation=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bInterpolation</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotates pInputImage to the dimensions specified by pOutputImage and stores the result in pOutputImage. </p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be either both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a> or both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">mx</td><td>The x-coordinate of the rotation center. </td></tr>
    <tr><td class="paramname">my</td><td>The y-coordinate of the rotation center. </td></tr>
    <tr><td class="paramname">theta</td><td>The rotation angle, given in radians. </td></tr>
    <tr><td class="paramname">bInterpolation</td><td>Determines whether bilinear interpolation is used or not. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l03651">3651</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0a46da9e8e96d255b1e8be830a995c84"></a><!-- doxytag: member="ImageProcessor::Rotate180Degrees" ref="a0a46da9e8e96d255b1e8be830a995c84" args="(const CByteImage *pInputImage, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Rotate180Degrees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotates a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> by 180 degrees and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be either both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a> or both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>.</p>
<p>If pInputImage and pOutputImage share the same memory area, the input image is copied to a temporary image first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l04007">4007</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a15023fba6db7c6159c8674202ee11bc8"></a><!-- doxytag: member="ImageProcessor::SobelX" ref="a15023fba6db7c6159c8674202ee11bc8" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, bool bAbsoluteValue=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::SobelX </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAbsoluteValue</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Filters a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with the SobelX operator and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>This function is a convenience function, creating an instance of <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>, calling <a class="el" href="namespace_image_processor.html#a832974296e6d1c7f844f3cdfa59af7a2" title="Filters a CByteImage with the SobelX operator and writes the result to a CShortImage.">SobelX(const CByteImage*, CShortImage*, bool)</a>, and then calling <a class="el" href="namespace_image_processor.html#a53d89906c569cf675efbb413012efce0" title="Converts a CShortImage to a grayscale CByteImage.">ConvertImage(const CShortImage*, CByteImage*)</a>. See the documentations of these functions for further information. Note that there is no runtime penalty if pInputImage and pOutputImage share the same memory area, since a temporary instance of <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a> is used for storing the result of the convolution in any case.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">bAbsoluteValue</td><td>If true, the absolute values are written to pOutputImage, i.e. edge direction information is lost. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l00780">780</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a832974296e6d1c7f844f3cdfa59af7a2"></a><!-- doxytag: member="ImageProcessor::SobelX" ref="a832974296e6d1c7f844f3cdfa59af7a2" args="(const CByteImage *pInputImage, CShortImage *pOutputImage, bool bAbsoluteValue=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::SobelX </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_short_image.html">CShortImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAbsoluteValue</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Filters a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with the SobelX operator and writes the result to a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>. </p>
<p>The SobelX operator computes gradients in x-direction and is thus suitable for the detection of vertical edges. The used filter kernel is: <img class="formulaInl" alt="$ \left(\begin{array}{ccc} -1 &amp; 0 &amp; 1\\ -2 &amp; 0 &amp; 2\\ -1 &amp; 0 &amp; 1\\ \end{array}\right) $" src="form_37.png"/>.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">bAbsoluteValue</td><td>If true, the absolute values are written to pOutputImage, i.e. edge direction information is lost. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l00840">840</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a65f699114febf20cf105d7eda847c8da"></a><!-- doxytag: member="ImageProcessor::SobelY" ref="a65f699114febf20cf105d7eda847c8da" args="(const CByteImage *pInputImage, CShortImage *pOutputImage, bool bAbsoluteValue=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::SobelY </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_short_image.html">CShortImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAbsoluteValue</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Filters a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with the SobelY operator and writes the result to a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>. </p>
<p>The SobelY operator computes gradients in y-direction and is thus suitable for the detection of horizontal edges. The used filter kernel is: <img class="formulaInl" alt="$ \left(\begin{array}{ccc} -1 &amp; -2 &amp; -1\\ 0 &amp; 0 &amp; 0\\ 1 &amp; 2 &amp; 1\\ \end{array}\right) $" src="form_38.png"/>.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">bAbsoluteValue</td><td>If true, the absolute values are written to pOutputImage, i.e. edge direction information is lost. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l00794">794</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed24f95ce40024df3f169cb09ff80af0"></a><!-- doxytag: member="ImageProcessor::SobelY" ref="aed24f95ce40024df3f169cb09ff80af0" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, bool bAbsoluteValue=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::SobelY </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAbsoluteValue</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Filters a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> with the SobelY operator and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>This function is a convenience function, creating an instance of <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a>, calling <a class="el" href="namespace_image_processor.html#a65f699114febf20cf105d7eda847c8da" title="Filters a CByteImage with the SobelY operator and writes the result to a CShortImage.">SobelY(const CByteImage*, CShortImage*, bool)</a>, and then calling <a class="el" href="namespace_image_processor.html#a53d89906c569cf675efbb413012efce0" title="Converts a CShortImage to a grayscale CByteImage.">ConvertImage(const CShortImage*, CByteImage*)</a>. See the documentations of these functions for further information. Note that there is no runtime penalty if pInputImage and pOutputImage share the same memory area, since a temporary instance of <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a> is used for storing the result of the convolution in any case.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 pInputImage and pOutputImage must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">bAbsoluteValue</td><td>If true, the absolute values are written to pOutputImage, i.e. edge direction information is lost. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l00787">787</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5775834e0c273da26cb7abd864d15e83"></a><!-- doxytag: member="ImageProcessor::Spread" ref="a5775834e0c273da26cb7abd864d15e83" args="(const CByteImage *pInputImage, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Spread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a spread operation on pInputImage and stores the result in pOutputImage. </p>
<p>Linearly maps the interval [min, max] to [0, 255], where min/max are the minimum/maximum value in pInputImage.<br/>
 If pInputImage is homogeneous, the values of pOutputImage are all set to zero.</p>
<p>The width and height of pInputImage and pOutputImage must match.<br/>
 Both images must be of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<p>As this is a point operation, there is no copy overhead if pInputImage and pOutputImage share the same memory area.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l01901">1901</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e5660739b545bebb13481ad81cb01d6"></a><!-- doxytag: member="ImageProcessor::Subtract" ref="a0e5660739b545bebb13481ad81cb01d6" args="(const CByteImage *pInputImage1, const CByteImage *pInputImage2, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Subtract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets each pixel in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to the difference between the corresponding pixels in two instances of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>This function implements the following point operation: pOutputImage-&gt;pixels[i] = pInputImage1-&gt;pixels[i] - pInputImage2-&gt;pixels[i].</p>
<p>No saturation is performed, i.e. overflows are not handled. For instance, 200 - 201 results in 255, 200 - 202 results in 254, and so on.</p>
<p>The width, height and type of pInputImage1, pInputImage2 and pOutputImage must match.<br/>
 All types of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> are supported (<a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea49137e7257d209b4b831bb271c2f69bf">CByteImage::eRGB24Split</a>).</p>
<p>As this is a point operation, there is no copy overhead if pInputImage1, pInputImage2, or pOutputImage share the same memory area.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage1</td><td>The first input image. </td></tr>
    <tr><td class="paramname">pInputImage2</td><td>The second input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l06677">6677</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a21217df8536dbfba18d6a3cded349ecd"></a><!-- doxytag: member="ImageProcessor::SubtractWithSaturation" ref="a21217df8536dbfba18d6a3cded349ecd" args="(const CByteImage *pInputImage1, const CByteImage *pInputImage2, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::SubtractWithSaturation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets each pixel in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to the difference between the corresponding pixels in two instances of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>, handling overflows with saturation. </p>
<p>This function implements the following point operation: pOutputImage-&gt;pixels[i] = MY_MAX((int) pInputImage1-&gt;pixels[i] + (int) pInputImage2-&gt;pixels[i], 0).</p>
<p>Saturation is performed, i.e. overflows are handled with truncation. For instance, 200 - 201 results in 0, 200 - 202 results in 0, and so on.</p>
<p>The width, height and type of pInputImage1, pInputImage2 and pOutputImage must match.<br/>
 All types of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> are supported (<a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea49137e7257d209b4b831bb271c2f69bf">CByteImage::eRGB24Split</a>).</p>
<p>As this is a point operation, there is no copy overhead if pInputImage1, pInputImage2, or pOutputImage share the same memory area.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage1</td><td>The first input image. </td></tr>
    <tr><td class="paramname">pInputImage2</td><td>The second input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l06699">6699</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a19edf5fbfcdf7d1d1840d140e5d37baa"></a><!-- doxytag: member="ImageProcessor::ThresholdBinarize" ref="a19edf5fbfcdf7d1d1840d140e5d37baa" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, unsigned char nThreshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::ThresholdBinarize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>nThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs threshold binarization to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>Sets each pixel in pOutputImage to 255 if the corresponding pixel in pInputImage has a value greater than or equal to nThreshold and to 0 otherwise.</p>
<p>The width and height of pInputImage and pOutputImage must match. pInputImage and pOutputImage must be both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<p>As this is a point operation, there is no copy overhead if pInputImage and pOutputImage share the same memory area.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">nThreshold</td><td>The threshold value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l03733">3733</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a932ce4e6df317b4ba5b051fcacdfe682"></a><!-- doxytag: member="ImageProcessor::ThresholdBinarize" ref="a932ce4e6df317b4ba5b051fcacdfe682" args="(const CFloatMatrix *pInputImage, CFloatMatrix *pOutputImage, float fThreshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::ThresholdBinarize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs threshold binarization to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a> and writes the result to a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a>. </p>
<p>Sets each pixel in pOutputImage to 255.0f if the corresponding pixel in pInputImage has a value greater than or equal to fThreshold and to 0.0f otherwise.</p>
<p>The number of columns and rows of pInputImage and pOutputImage must match.</p>
<p>As this is a point operation, there is no copy overhead if pInputImage and pOutputImage share the same memory area.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">fThreshold</td><td>The threshold value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l03754">3754</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8b7459d83cd8f74d5c7bc5d44dfec8f5"></a><!-- doxytag: member="ImageProcessor::ThresholdBinarizeInverse" ref="a8b7459d83cd8f74d5c7bc5d44dfec8f5" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, unsigned char nThreshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::ThresholdBinarizeInverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>nThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs inverse threshold binarization to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>Sets each pixel in pOutputImage to 255 if the corresponding pixel in pInputImage has a value less than or equal to nThreshold and to 0 otherwise.</p>
<p>The width and height of pInputImage and pOutputImage must match. pInputImage and pOutputImage must be both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<p>As this is a point operation, there is no copy overhead if pInputImage and pOutputImage share the same memory area.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">nThreshold</td><td>The threshold value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l03770">3770</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a65db3e105be8ca835ada1e073433d264"></a><!-- doxytag: member="ImageProcessor::ThresholdFilter" ref="a65db3e105be8ca835ada1e073433d264" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, unsigned char nThreshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::ThresholdFilter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>nThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs threhold filtering to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>Copies each pixel in pOutputImage if the corresponding pixel in pInputImage has a value greater than or equal to nThreshold and sets it to 0 otherwise.</p>
<p>The width and height of pInputImage and pOutputImage must match. pInputImage and pOutputImage must be both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<p>As this is a point operation, there is no copy overhead if pInputImage and pOutputImage share the same memory area.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">nThreshold</td><td>The threshold value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l03791">3791</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab72a6ac0659b3ecc792bdb652b337817"></a><!-- doxytag: member="ImageProcessor::ThresholdFilterInverse" ref="ab72a6ac0659b3ecc792bdb652b337817" args="(const CByteImage *pInputImage, CByteImage *pOutputImage, unsigned char nThreshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::ThresholdFilterInverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>nThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs inverse threhold filtering to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>Copies each pixel in pOutputImage if the corresponding pixel in pInputImage has a value less than or equal to nThreshold and sets it to 0 otherwise.</p>
<p>The width and height of pInputImage and pOutputImage must match. pInputImage and pOutputImage must be both of type <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>.</p>
<p>As this is a point operation, there is no copy overhead if pInputImage and pOutputImage share the same memory area.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage</td><td>The input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
    <tr><td class="paramname">nThreshold</td><td>The threshold value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l03812">3812</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afe043722c0e2b50cb661a015b644f7e0"></a><!-- doxytag: member="ImageProcessor::Xor" ref="afe043722c0e2b50cb661a015b644f7e0" args="(const CByteImage *pInputImage1, const CByteImage *pInputImage2, CByteImage *pOutputImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Xor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pInputImage2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pOutputImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the bitwise operator XOR to two instance of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> and writes the result to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>This function implements the following point operation: pOutputImage-&gt;pixels[i] = pInputImage1-&gt;pixels[i] ^ pInputImage2-&gt;pixels[i].</p>
<p>The width, height and type of pInputImage1, pInputImage2 and pOutputImage must match.<br/>
 All types of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> are supported (<a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">CByteImage::eGrayScale</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a>, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea49137e7257d209b4b831bb271c2f69bf">CByteImage::eRGB24Split</a>).</p>
<p>As this is a point operation, there is no copy overhead if pInputImage1, pInputImage2, or pOutputImage share the same memory area.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pInputImage1</td><td>The first input image. </td></tr>
    <tr><td class="paramname">pInputImage2</td><td>The second input image. </td></tr>
    <tr><td class="paramname">pOutputImage</td><td>The output image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l06590">6590</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae0ff463562fada0b7f1f3bee665ecf1a"></a><!-- doxytag: member="ImageProcessor::Zero" ref="ae0ff463562fada0b7f1f3bee665ecf1a" args="(CShortImage *pImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_short_image.html">CShortImage</a> *&#160;</td>
          <td class="paramname"><em>pImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets all values in a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a> to zero. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pImage</td><td>The image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02843">2843</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ade446a86e131c0315ea33c228c39d692"></a><!-- doxytag: member="ImageProcessor::Zero" ref="ade446a86e131c0315ea33c228c39d692" args="(CByteImage *pImage, const MyRegion *pROI=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_my_region.html">MyRegion</a> *&#160;</td>
          <td class="paramname"><em>pROI</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets all values in a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to zero. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pImage</td><td>The image. </td></tr>
    <tr><td class="paramname">pROI</td><td>The region which contains the values which shall be set to zero. If pROI is 0, then all pixels of pImage are set to zero. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02783">2783</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad95490e1437fc504620fff392fd2ceca"></a><!-- doxytag: member="ImageProcessor::Zero" ref="ad95490e1437fc504620fff392fd2ceca" args="(CDoubleMatrix *pImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_double_matrix.html">CDoubleMatrix</a> *&#160;</td>
          <td class="paramname"><em>pImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets all values in a <a class="el" href="class_c_double_matrix.html" title="Data structure for the representation of a matrix of values of the data type double.">CDoubleMatrix</a> to zero. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pImage</td><td>The image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02858">2858</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a48ac73db390aa35de5e950436bf48f1b"></a><!-- doxytag: member="ImageProcessor::Zero" ref="a48ac73db390aa35de5e950436bf48f1b" args="(CIntImage *pImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_int_image.html">CIntImage</a> *&#160;</td>
          <td class="paramname"><em>pImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets all values in a <a class="el" href="class_c_int_image.html" title="Data structure for the representation of single channel images of the data type signed int...">CIntImage</a> to zero. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pImage</td><td>The image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02848">2848</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a237b98cc8adadf06a90fd13ec878e15f"></a><!-- doxytag: member="ImageProcessor::Zero" ref="a237b98cc8adadf06a90fd13ec878e15f" args="(CFloatMatrix *pImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::Zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_float_matrix.html">CFloatMatrix</a> *&#160;</td>
          <td class="paramname"><em>pImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets all values in a <a class="el" href="class_c_float_matrix.html" title="Data structure for the representation of a matrix of values of the data type float.">CFloatMatrix</a> to zero. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pImage</td><td>The image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02853">2853</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2e0ef07a0e16170d5fc08c6e025b68a3"></a><!-- doxytag: member="ImageProcessor::ZeroFrame" ref="a2e0ef07a0e16170d5fc08c6e025b68a3" args="(CShortImage *pImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::ZeroFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_short_image.html">CShortImage</a> *&#160;</td>
          <td class="paramname"><em>pImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets all pixels on a one pixel wide frame of a <a class="el" href="class_c_short_image.html" title="Data structure for the representation of single channel images of the data type signed short...">CShortImage</a> to zero. </p>
<p>The frame consists of the top and bottom row as well as the leftmost and rightmost column.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pImage</td><td>The target image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02900">2900</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aefe8dd246421ba8c838be0accb7f5e95"></a><!-- doxytag: member="ImageProcessor::ZeroFrame" ref="aefe8dd246421ba8c838be0accb7f5e95" args="(CByteImage *pImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::ZeroFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets all pixels on a one pixel wide frame of a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> to zero. </p>
<p>The frame consists of the top and bottom row as well as the leftmost and rightmost column.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pImage</td><td>The target image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02864">2864</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad5c35606a667dbea8cb6ce5568f6f0df"></a><!-- doxytag: member="ImageProcessor::ZeroFrame" ref="ad5c35606a667dbea8cb6ce5568f6f0df" args="(CIntImage *pImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageProcessor::ZeroFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_int_image.html">CIntImage</a> *&#160;</td>
          <td class="paramname"><em>pImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets all pixels on a one pixel wide frame of a <a class="el" href="class_c_int_image.html" title="Data structure for the representation of single channel images of the data type signed int...">CIntImage</a> to zero. </p>
<p>The frame consists of the top and bottom row as well as the leftmost and rightmost column.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pImage</td><td>The target image. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_image_processor_8cpp_source.html#l02918">2918</a> of file <a class="el" href="_image_processor_8cpp_source.html">ImageProcessor.cpp</a>.</p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespace_image_processor.html">ImageProcessor</a>      </li>
      <li class="footer">Generated on Thu May 24 2012 16:39:59 for IVT by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>

</body>
</html>
